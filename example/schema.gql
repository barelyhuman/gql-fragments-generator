type AccessTokenOutput {
	token: String!
}

type Activity {
	action: JSON
	createdAt: DateTime!
	id: Int!
	updatedAt: DateTime!
	user: User!
	userId: Int!
}

type ActivityAvgAggregate {
	id: Float
	userId: Float
}

input ActivityAvgOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

type ActivityCountAggregate {
	_all: Int!
	action: Int!
	createdAt: Int!
	id: Int!
	updatedAt: Int!
	userId: Int!
}

input ActivityCountOrderByAggregateInput {
	action: SortOrder
	createdAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ActivityCreateInput {
	action: JSON
	createdAt: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutActivityInput!
}

input ActivityCreateManyInput {
	action: JSON
	createdAt: DateTime
	id: Int
	updatedAt: DateTime
	userId: Int!
}

input ActivityCreateManyUserInput {
	action: JSON
	createdAt: DateTime
	id: Int
	updatedAt: DateTime
}

input ActivityCreateManyUserInputEnvelope {
	data: [ActivityCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input ActivityCreateNestedManyWithoutUserInput {
	connect: [ActivityWhereUniqueInput!]
	connectOrCreate: [ActivityCreateOrConnectWithoutUserInput!]
	create: [ActivityCreateWithoutUserInput!]
	createMany: ActivityCreateManyUserInputEnvelope
}

input ActivityCreateOrConnectWithoutUserInput {
	create: ActivityCreateWithoutUserInput!
	where: ActivityWhereUniqueInput!
}

input ActivityCreateWithoutUserInput {
	action: JSON
	createdAt: DateTime
	updatedAt: DateTime
}

type ActivityGroupBy {
	_avg: ActivityAvgAggregate
	_count: ActivityCountAggregate
	_max: ActivityMaxAggregate
	_min: ActivityMinAggregate
	_sum: ActivitySumAggregate
	action: JSON
	createdAt: DateTime!
	id: Int!
	updatedAt: DateTime!
	userId: Int!
}

input ActivityListRelationFilter {
	every: ActivityWhereInput
	none: ActivityWhereInput
	some: ActivityWhereInput
}

type ActivityMaxAggregate {
	createdAt: DateTime
	id: Int
	updatedAt: DateTime
	userId: Int
}

input ActivityMaxOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

type ActivityMinAggregate {
	createdAt: DateTime
	id: Int
	updatedAt: DateTime
	userId: Int
}

input ActivityMinOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ActivityOrderByRelationAggregateInput {
	_count: SortOrder
}

input ActivityOrderByWithAggregationInput {
	_avg: ActivityAvgOrderByAggregateInput
	_count: ActivityCountOrderByAggregateInput
	_max: ActivityMaxOrderByAggregateInput
	_min: ActivityMinOrderByAggregateInput
	_sum: ActivitySumOrderByAggregateInput
	action: SortOrder
	createdAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ActivityOrderByWithRelationInput {
	action: SortOrder
	createdAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
}

enum ActivityScalarFieldEnum {
	action
	createdAt
	id
	updatedAt
	userId
}

input ActivityScalarWhereInput {
	AND: [ActivityScalarWhereInput!]
	NOT: [ActivityScalarWhereInput!]
	OR: [ActivityScalarWhereInput!]
	action: JsonNullableFilter
	createdAt: DateTimeFilter
	id: IntFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
}

input ActivityScalarWhereWithAggregatesInput {
	AND: [ActivityScalarWhereWithAggregatesInput!]
	NOT: [ActivityScalarWhereWithAggregatesInput!]
	OR: [ActivityScalarWhereWithAggregatesInput!]
	action: JsonNullableWithAggregatesFilter
	createdAt: DateTimeWithAggregatesFilter
	id: IntWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
}

type ActivitySumAggregate {
	id: Int
	userId: Int
}

input ActivitySumOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

input ActivityUpdateInput {
	action: JSON
	createdAt: DateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutActivityInput
}

input ActivityUpdateManyMutationInput {
	action: JSON
	createdAt: DateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActivityUpdateManyWithWhereWithoutUserInput {
	data: ActivityUpdateManyMutationInput!
	where: ActivityScalarWhereInput!
}

input ActivityUpdateManyWithoutUserInput {
	connect: [ActivityWhereUniqueInput!]
	connectOrCreate: [ActivityCreateOrConnectWithoutUserInput!]
	create: [ActivityCreateWithoutUserInput!]
	createMany: ActivityCreateManyUserInputEnvelope
	delete: [ActivityWhereUniqueInput!]
	deleteMany: [ActivityScalarWhereInput!]
	disconnect: [ActivityWhereUniqueInput!]
	set: [ActivityWhereUniqueInput!]
	update: [ActivityUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [ActivityUpdateManyWithWhereWithoutUserInput!]
	upsert: [ActivityUpsertWithWhereUniqueWithoutUserInput!]
}

input ActivityUpdateWithWhereUniqueWithoutUserInput {
	data: ActivityUpdateWithoutUserInput!
	where: ActivityWhereUniqueInput!
}

input ActivityUpdateWithoutUserInput {
	action: JSON
	createdAt: DateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ActivityUpsertWithWhereUniqueWithoutUserInput {
	create: ActivityCreateWithoutUserInput!
	update: ActivityUpdateWithoutUserInput!
	where: ActivityWhereUniqueInput!
}

input ActivityWhereInput {
	AND: [ActivityWhereInput!]
	NOT: [ActivityWhereInput!]
	OR: [ActivityWhereInput!]
	action: JsonNullableFilter
	createdAt: DateTimeFilter
	id: IntFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
}

input ActivityWhereUniqueInput {
	id: Int
}

type Address {
	city: String!
	country: Country
	countryId: Int
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime!
	user: User!
	userId: Int!
	zipcode: String!
}

type AddressAvgAggregate {
	countryId: Float
	id: Float
	lat: Float
	lng: Float
	userId: Float
}

input AddressAvgOrderByAggregateInput {
	countryId: SortOrder
	id: SortOrder
	lat: SortOrder
	lng: SortOrder
	userId: SortOrder
}

type AddressCountAggregate {
	_all: Int!
	city: Int!
	countryId: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	lat: Int!
	lng: Int!
	street: Int!
	updatedAt: Int!
	userId: Int!
	zipcode: Int!
}

input AddressCountOrderByAggregateInput {
	city: SortOrder
	countryId: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	lat: SortOrder
	lng: SortOrder
	street: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	zipcode: SortOrder
}

input AddressCreateInput {
	city: String!
	country: CountryCreateNestedOneWithoutAddressInput
	createdAt: DateTime
	deletedAt: DateTime
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutAddressesInput!
	zipcode: String!
}

input AddressCreateManyCountryInput {
	city: String!
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime
	userId: Int!
	zipcode: String!
}

input AddressCreateManyCountryInputEnvelope {
	data: [AddressCreateManyCountryInput!]!
	skipDuplicates: Boolean
}

input AddressCreateManyInput {
	city: String!
	countryId: Int
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime
	userId: Int!
	zipcode: String!
}

input AddressCreateManyUserInput {
	city: String!
	countryId: Int
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime
	zipcode: String!
}

input AddressCreateManyUserInputEnvelope {
	data: [AddressCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input AddressCreateNestedManyWithoutCountryInput {
	connect: [AddressWhereUniqueInput!]
	connectOrCreate: [AddressCreateOrConnectWithoutCountryInput!]
	create: [AddressCreateWithoutCountryInput!]
	createMany: AddressCreateManyCountryInputEnvelope
}

input AddressCreateNestedManyWithoutUserInput {
	connect: [AddressWhereUniqueInput!]
	connectOrCreate: [AddressCreateOrConnectWithoutUserInput!]
	create: [AddressCreateWithoutUserInput!]
	createMany: AddressCreateManyUserInputEnvelope
}

input AddressCreateOrConnectWithoutCountryInput {
	create: AddressCreateWithoutCountryInput!
	where: AddressWhereUniqueInput!
}

input AddressCreateOrConnectWithoutUserInput {
	create: AddressCreateWithoutUserInput!
	where: AddressWhereUniqueInput!
}

input AddressCreateWithoutCountryInput {
	city: String!
	createdAt: DateTime
	deletedAt: DateTime
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutAddressesInput!
	zipcode: String!
}

input AddressCreateWithoutUserInput {
	city: String!
	country: CountryCreateNestedOneWithoutAddressInput
	createdAt: DateTime
	deletedAt: DateTime
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime
	zipcode: String!
}

type AddressGroupBy {
	_avg: AddressAvgAggregate
	_count: AddressCountAggregate
	_max: AddressMaxAggregate
	_min: AddressMinAggregate
	_sum: AddressSumAggregate
	city: String!
	countryId: Int
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	lat: Float
	lng: Float
	street: String!
	updatedAt: DateTime!
	userId: Int!
	zipcode: String!
}

input AddressListRelationFilter {
	every: AddressWhereInput
	none: AddressWhereInput
	some: AddressWhereInput
}

type AddressMaxAggregate {
	city: String
	countryId: Int
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	lat: Float
	lng: Float
	street: String
	updatedAt: DateTime
	userId: Int
	zipcode: String
}

input AddressMaxOrderByAggregateInput {
	city: SortOrder
	countryId: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	lat: SortOrder
	lng: SortOrder
	street: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	zipcode: SortOrder
}

type AddressMinAggregate {
	city: String
	countryId: Int
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	lat: Float
	lng: Float
	street: String
	updatedAt: DateTime
	userId: Int
	zipcode: String
}

input AddressMinOrderByAggregateInput {
	city: SortOrder
	countryId: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	lat: SortOrder
	lng: SortOrder
	street: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	zipcode: SortOrder
}

input AddressOrderByRelationAggregateInput {
	_count: SortOrder
}

input AddressOrderByWithAggregationInput {
	_avg: AddressAvgOrderByAggregateInput
	_count: AddressCountOrderByAggregateInput
	_max: AddressMaxOrderByAggregateInput
	_min: AddressMinOrderByAggregateInput
	_sum: AddressSumOrderByAggregateInput
	city: SortOrder
	countryId: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	lat: SortOrder
	lng: SortOrder
	street: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	zipcode: SortOrder
}

input AddressOrderByWithRelationInput {
	city: SortOrder
	country: CountryOrderByWithRelationInput
	countryId: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	lat: SortOrder
	lng: SortOrder
	street: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
	zipcode: SortOrder
}

enum AddressScalarFieldEnum {
	city
	countryId
	createdAt
	deletedAt
	id
	lat
	lng
	street
	updatedAt
	userId
	zipcode
}

input AddressScalarWhereInput {
	AND: [AddressScalarWhereInput!]
	NOT: [AddressScalarWhereInput!]
	OR: [AddressScalarWhereInput!]
	city: StringFilter
	countryId: IntNullableFilter
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	lat: FloatNullableFilter
	lng: FloatNullableFilter
	street: StringFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
	zipcode: StringFilter
}

input AddressScalarWhereWithAggregatesInput {
	AND: [AddressScalarWhereWithAggregatesInput!]
	NOT: [AddressScalarWhereWithAggregatesInput!]
	OR: [AddressScalarWhereWithAggregatesInput!]
	city: StringWithAggregatesFilter
	countryId: IntNullableWithAggregatesFilter
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	lat: FloatNullableWithAggregatesFilter
	lng: FloatNullableWithAggregatesFilter
	street: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
	zipcode: StringWithAggregatesFilter
}

type AddressSumAggregate {
	countryId: Int
	id: Int
	lat: Float
	lng: Float
	userId: Int
}

input AddressSumOrderByAggregateInput {
	countryId: SortOrder
	id: SortOrder
	lat: SortOrder
	lng: SortOrder
	userId: SortOrder
}

input AddressUpdateInput {
	city: StringFieldUpdateOperationsInput
	country: CountryUpdateOneWithoutAddressInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	lat: NullableFloatFieldUpdateOperationsInput
	lng: NullableFloatFieldUpdateOperationsInput
	street: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutAddressesInput
	zipcode: StringFieldUpdateOperationsInput
}

input AddressUpdateManyMutationInput {
	city: StringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	lat: NullableFloatFieldUpdateOperationsInput
	lng: NullableFloatFieldUpdateOperationsInput
	street: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	zipcode: StringFieldUpdateOperationsInput
}

input AddressUpdateManyWithWhereWithoutCountryInput {
	data: AddressUpdateManyMutationInput!
	where: AddressScalarWhereInput!
}

input AddressUpdateManyWithWhereWithoutUserInput {
	data: AddressUpdateManyMutationInput!
	where: AddressScalarWhereInput!
}

input AddressUpdateManyWithoutCountryInput {
	connect: [AddressWhereUniqueInput!]
	connectOrCreate: [AddressCreateOrConnectWithoutCountryInput!]
	create: [AddressCreateWithoutCountryInput!]
	createMany: AddressCreateManyCountryInputEnvelope
	delete: [AddressWhereUniqueInput!]
	deleteMany: [AddressScalarWhereInput!]
	disconnect: [AddressWhereUniqueInput!]
	set: [AddressWhereUniqueInput!]
	update: [AddressUpdateWithWhereUniqueWithoutCountryInput!]
	updateMany: [AddressUpdateManyWithWhereWithoutCountryInput!]
	upsert: [AddressUpsertWithWhereUniqueWithoutCountryInput!]
}

input AddressUpdateManyWithoutUserInput {
	connect: [AddressWhereUniqueInput!]
	connectOrCreate: [AddressCreateOrConnectWithoutUserInput!]
	create: [AddressCreateWithoutUserInput!]
	createMany: AddressCreateManyUserInputEnvelope
	delete: [AddressWhereUniqueInput!]
	deleteMany: [AddressScalarWhereInput!]
	disconnect: [AddressWhereUniqueInput!]
	set: [AddressWhereUniqueInput!]
	update: [AddressUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [AddressUpdateManyWithWhereWithoutUserInput!]
	upsert: [AddressUpsertWithWhereUniqueWithoutUserInput!]
}

input AddressUpdateWithWhereUniqueWithoutCountryInput {
	data: AddressUpdateWithoutCountryInput!
	where: AddressWhereUniqueInput!
}

input AddressUpdateWithWhereUniqueWithoutUserInput {
	data: AddressUpdateWithoutUserInput!
	where: AddressWhereUniqueInput!
}

input AddressUpdateWithoutCountryInput {
	city: StringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	lat: NullableFloatFieldUpdateOperationsInput
	lng: NullableFloatFieldUpdateOperationsInput
	street: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutAddressesInput
	zipcode: StringFieldUpdateOperationsInput
}

input AddressUpdateWithoutUserInput {
	city: StringFieldUpdateOperationsInput
	country: CountryUpdateOneWithoutAddressInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	lat: NullableFloatFieldUpdateOperationsInput
	lng: NullableFloatFieldUpdateOperationsInput
	street: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	zipcode: StringFieldUpdateOperationsInput
}

input AddressUpsertWithWhereUniqueWithoutCountryInput {
	create: AddressCreateWithoutCountryInput!
	update: AddressUpdateWithoutCountryInput!
	where: AddressWhereUniqueInput!
}

input AddressUpsertWithWhereUniqueWithoutUserInput {
	create: AddressCreateWithoutUserInput!
	update: AddressUpdateWithoutUserInput!
	where: AddressWhereUniqueInput!
}

input AddressWhereInput {
	AND: [AddressWhereInput!]
	NOT: [AddressWhereInput!]
	OR: [AddressWhereInput!]
	city: StringFilter
	country: CountryRelationFilter
	countryId: IntNullableFilter
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	lat: FloatNullableFilter
	lng: FloatNullableFilter
	street: StringFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
	zipcode: StringFilter
}

input AddressWhereUniqueInput {
	id: Int
}

type AffectedRowsOutput {
	count: Int!
}

type AggregateActivity {
	_avg: ActivityAvgAggregate
	_count: ActivityCountAggregate
	_max: ActivityMaxAggregate
	_min: ActivityMinAggregate
	_sum: ActivitySumAggregate
}

type AggregateAddress {
	_avg: AddressAvgAggregate
	_count: AddressCountAggregate
	_max: AddressMaxAggregate
	_min: AddressMinAggregate
	_sum: AddressSumAggregate
}

type AggregateComment {
	_avg: CommentAvgAggregate
	_count: CommentCountAggregate
	_max: CommentMaxAggregate
	_min: CommentMinAggregate
	_sum: CommentSumAggregate
}

type AggregateCountry {
	_avg: CountryAvgAggregate
	_count: CountryCountAggregate
	_max: CountryMaxAggregate
	_min: CountryMinAggregate
	_sum: CountrySumAggregate
}

type AggregateDomain {
	_avg: DomainAvgAggregate
	_count: DomainCountAggregate
	_max: DomainMaxAggregate
	_min: DomainMinAggregate
	_sum: DomainSumAggregate
}

type AggregateEducation {
	_avg: EducationAvgAggregate
	_count: EducationCountAggregate
	_max: EducationMaxAggregate
	_min: EducationMinAggregate
	_sum: EducationSumAggregate
}

type AggregateEmploymentType {
	_avg: EmploymentTypeAvgAggregate
	_count: EmploymentTypeCountAggregate
	_max: EmploymentTypeMaxAggregate
	_min: EmploymentTypeMinAggregate
	_sum: EmploymentTypeSumAggregate
}

type AggregateExperience {
	_avg: ExperienceAvgAggregate
	_count: ExperienceCountAggregate
	_max: ExperienceMaxAggregate
	_min: ExperienceMinAggregate
	_sum: ExperienceSumAggregate
}

type AggregateExperienceRole {
	_avg: ExperienceRoleAvgAggregate
	_count: ExperienceRoleCountAggregate
	_max: ExperienceRoleMaxAggregate
	_min: ExperienceRoleMinAggregate
	_sum: ExperienceRoleSumAggregate
}

type AggregateInvitation {
	_avg: InvitationAvgAggregate
	_count: InvitationCountAggregate
	_max: InvitationMaxAggregate
	_min: InvitationMinAggregate
	_sum: InvitationSumAggregate
}

type AggregatePost {
	_avg: PostAvgAggregate
	_count: PostCountAggregate
	_max: PostMaxAggregate
	_min: PostMinAggregate
	_sum: PostSumAggregate
}

type AggregateProfile {
	_avg: ProfileAvgAggregate
	_count: ProfileCountAggregate
	_max: ProfileMaxAggregate
	_min: ProfileMinAggregate
	_sum: ProfileSumAggregate
}

type AggregateProject {
	_avg: ProjectAvgAggregate
	_count: ProjectCountAggregate
	_max: ProjectMaxAggregate
	_min: ProjectMinAggregate
	_sum: ProjectSumAggregate
}

type AggregateRole {
	_avg: RoleAvgAggregate
	_count: RoleCountAggregate
	_max: RoleMaxAggregate
	_min: RoleMinAggregate
	_sum: RoleSumAggregate
}

type AggregateScircle {
	_avg: ScircleAvgAggregate
	_count: ScircleCountAggregate
	_max: ScircleMaxAggregate
	_min: ScircleMinAggregate
	_sum: ScircleSumAggregate
}

type AggregateSkill {
	_avg: SkillAvgAggregate
	_count: SkillCountAggregate
	_max: SkillMaxAggregate
	_min: SkillMinAggregate
	_sum: SkillSumAggregate
}

type AggregateToken {
	_avg: TokenAvgAggregate
	_count: TokenCountAggregate
	_max: TokenMaxAggregate
	_min: TokenMinAggregate
	_sum: TokenSumAggregate
}

type AggregateUser {
	_avg: UserAvgAggregate
	_count: UserCountAggregate
	_max: UserMaxAggregate
	_min: UserMinAggregate
	_sum: UserSumAggregate
}

type AggregateUserProject {
	_avg: UserProjectAvgAggregate
	_count: UserProjectCountAggregate
	_max: UserProjectMaxAggregate
	_min: UserProjectMinAggregate
	_sum: UserProjectSumAggregate
}

type AggregateUserProjectRole {
	_avg: UserProjectRoleAvgAggregate
	_count: UserProjectRoleCountAggregate
	_max: UserProjectRoleMaxAggregate
	_min: UserProjectRoleMinAggregate
	_sum: UserProjectRoleSumAggregate
}

type AggregateUserRoleMapping {
	_avg: UserRoleMappingAvgAggregate
	_count: UserRoleMappingCountAggregate
	_max: UserRoleMappingMaxAggregate
	_min: UserRoleMappingMinAggregate
	_sum: UserRoleMappingSumAggregate
}

input BoolFieldUpdateOperationsInput {
	set: Boolean
}

input BoolFilter {
	equals: Boolean
	not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
	_count: NestedIntFilter
	_max: NestedBoolFilter
	_min: NestedBoolFilter
	equals: Boolean
	not: NestedBoolWithAggregatesFilter
}

type Comment {
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	updatedAt: DateTime!
	user: User!
	userId: Int!
}

type CommentAvgAggregate {
	id: Float
	userId: Float
}

input CommentAvgOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

type CommentCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	updatedAt: Int!
	userId: Int!
}

input CommentCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input CommentCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutCommentsInput!
}

input CommentCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
	userId: Int!
}

input CommentCreateManyUserInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
}

input CommentCreateManyUserInputEnvelope {
	data: [CommentCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutUserInput {
	connect: [CommentWhereUniqueInput!]
	connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
	create: [CommentCreateWithoutUserInput!]
	createMany: CommentCreateManyUserInputEnvelope
}

input CommentCreateOrConnectWithoutUserInput {
	create: CommentCreateWithoutUserInput!
	where: CommentWhereUniqueInput!
}

input CommentCreateWithoutUserInput {
	createdAt: DateTime
	deletedAt: DateTime
	updatedAt: DateTime
}

type CommentGroupBy {
	_avg: CommentAvgAggregate
	_count: CommentCountAggregate
	_max: CommentMaxAggregate
	_min: CommentMinAggregate
	_sum: CommentSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	updatedAt: DateTime!
	userId: Int!
}

input CommentListRelationFilter {
	every: CommentWhereInput
	none: CommentWhereInput
	some: CommentWhereInput
}

type CommentMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
	userId: Int
}

input CommentMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

type CommentMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
	userId: Int
}

input CommentMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input CommentOrderByRelationAggregateInput {
	_count: SortOrder
}

input CommentOrderByWithAggregationInput {
	_avg: CommentAvgOrderByAggregateInput
	_count: CommentCountOrderByAggregateInput
	_max: CommentMaxOrderByAggregateInput
	_min: CommentMinOrderByAggregateInput
	_sum: CommentSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input CommentOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
}

enum CommentScalarFieldEnum {
	createdAt
	deletedAt
	id
	updatedAt
	userId
}

input CommentScalarWhereInput {
	AND: [CommentScalarWhereInput!]
	NOT: [CommentScalarWhereInput!]
	OR: [CommentScalarWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
}

input CommentScalarWhereWithAggregatesInput {
	AND: [CommentScalarWhereWithAggregatesInput!]
	NOT: [CommentScalarWhereWithAggregatesInput!]
	OR: [CommentScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
}

type CommentSumAggregate {
	id: Int
	userId: Int
}

input CommentSumOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

input CommentUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyWithWhereWithoutUserInput {
	data: CommentUpdateManyMutationInput!
	where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutUserInput {
	connect: [CommentWhereUniqueInput!]
	connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
	create: [CommentCreateWithoutUserInput!]
	createMany: CommentCreateManyUserInputEnvelope
	delete: [CommentWhereUniqueInput!]
	deleteMany: [CommentScalarWhereInput!]
	disconnect: [CommentWhereUniqueInput!]
	set: [CommentWhereUniqueInput!]
	update: [CommentUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [CommentUpdateManyWithWhereWithoutUserInput!]
	upsert: [CommentUpsertWithWhereUniqueWithoutUserInput!]
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
	data: CommentUpdateWithoutUserInput!
	where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutUserInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
	create: CommentCreateWithoutUserInput!
	update: CommentUpdateWithoutUserInput!
	where: CommentWhereUniqueInput!
}

input CommentWhereInput {
	AND: [CommentWhereInput!]
	NOT: [CommentWhereInput!]
	OR: [CommentWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
}

input CommentWhereUniqueInput {
	id: Int
}

type Country {
	_count: CountryCount
	address(
		cursor: AddressWhereUniqueInput
		distinct: [AddressScalarFieldEnum!]
		orderBy: [AddressOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: AddressWhereInput
	): [Address!]!
	createdAt: DateTime!
	id: Int!
	name: String!
	shortCode: String
	updatedAt: DateTime!
}

type CountryAvgAggregate {
	id: Float
}

input CountryAvgOrderByAggregateInput {
	id: SortOrder
}

type CountryCount {
	address: Int!
}

type CountryCountAggregate {
	_all: Int!
	createdAt: Int!
	id: Int!
	name: Int!
	shortCode: Int!
	updatedAt: Int!
}

input CountryCountOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	name: SortOrder
	shortCode: SortOrder
	updatedAt: SortOrder
}

input CountryCreateInput {
	address: AddressCreateNestedManyWithoutCountryInput
	createdAt: DateTime
	name: String!
	shortCode: String
	updatedAt: DateTime
}

input CountryCreateManyInput {
	createdAt: DateTime
	id: Int
	name: String!
	shortCode: String
	updatedAt: DateTime
}

input CountryCreateNestedOneWithoutAddressInput {
	connect: CountryWhereUniqueInput
	connectOrCreate: CountryCreateOrConnectWithoutAddressInput
	create: CountryCreateWithoutAddressInput
}

input CountryCreateOrConnectWithoutAddressInput {
	create: CountryCreateWithoutAddressInput!
	where: CountryWhereUniqueInput!
}

input CountryCreateWithoutAddressInput {
	createdAt: DateTime
	name: String!
	shortCode: String
	updatedAt: DateTime
}

type CountryGroupBy {
	_avg: CountryAvgAggregate
	_count: CountryCountAggregate
	_max: CountryMaxAggregate
	_min: CountryMinAggregate
	_sum: CountrySumAggregate
	createdAt: DateTime!
	id: Int!
	name: String!
	shortCode: String
	updatedAt: DateTime!
}

type CountryMaxAggregate {
	createdAt: DateTime
	id: Int
	name: String
	shortCode: String
	updatedAt: DateTime
}

input CountryMaxOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	name: SortOrder
	shortCode: SortOrder
	updatedAt: SortOrder
}

type CountryMinAggregate {
	createdAt: DateTime
	id: Int
	name: String
	shortCode: String
	updatedAt: DateTime
}

input CountryMinOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	name: SortOrder
	shortCode: SortOrder
	updatedAt: SortOrder
}

input CountryOrderByWithAggregationInput {
	_avg: CountryAvgOrderByAggregateInput
	_count: CountryCountOrderByAggregateInput
	_max: CountryMaxOrderByAggregateInput
	_min: CountryMinOrderByAggregateInput
	_sum: CountrySumOrderByAggregateInput
	createdAt: SortOrder
	id: SortOrder
	name: SortOrder
	shortCode: SortOrder
	updatedAt: SortOrder
}

input CountryOrderByWithRelationInput {
	address: AddressOrderByRelationAggregateInput
	createdAt: SortOrder
	id: SortOrder
	name: SortOrder
	shortCode: SortOrder
	updatedAt: SortOrder
}

input CountryRelationFilter {
	is: CountryWhereInput
	isNot: CountryWhereInput
}

enum CountryScalarFieldEnum {
	createdAt
	id
	name
	shortCode
	updatedAt
}

input CountryScalarWhereWithAggregatesInput {
	AND: [CountryScalarWhereWithAggregatesInput!]
	NOT: [CountryScalarWhereWithAggregatesInput!]
	OR: [CountryScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	shortCode: StringNullableWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type CountrySumAggregate {
	id: Int
}

input CountrySumOrderByAggregateInput {
	id: SortOrder
}

input CountryUpdateInput {
	address: AddressUpdateManyWithoutCountryInput
	createdAt: DateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	shortCode: NullableStringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input CountryUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	shortCode: NullableStringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input CountryUpdateOneWithoutAddressInput {
	connect: CountryWhereUniqueInput
	connectOrCreate: CountryCreateOrConnectWithoutAddressInput
	create: CountryCreateWithoutAddressInput
	delete: Boolean
	disconnect: Boolean
	update: CountryUpdateWithoutAddressInput
	upsert: CountryUpsertWithoutAddressInput
}

input CountryUpdateWithoutAddressInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	shortCode: NullableStringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input CountryUpsertWithoutAddressInput {
	create: CountryCreateWithoutAddressInput!
	update: CountryUpdateWithoutAddressInput!
}

input CountryWhereInput {
	AND: [CountryWhereInput!]
	NOT: [CountryWhereInput!]
	OR: [CountryWhereInput!]
	address: AddressListRelationFilter
	createdAt: DateTimeFilter
	id: IntFilter
	name: StringFilter
	shortCode: StringNullableFilter
	updatedAt: DateTimeFilter
}

input CountryWhereUniqueInput {
	id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
	set: DateTime
}

input DateTimeFilter {
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeFilter
	notIn: [DateTime!]
}

input DateTimeNullableFilter {
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeNullableFilter
	notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
	_count: NestedIntNullableFilter
	_max: NestedDateTimeNullableFilter
	_min: NestedDateTimeNullableFilter
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeNullableWithAggregatesFilter
	notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
	_count: NestedIntFilter
	_max: NestedDateTimeFilter
	_min: NestedDateTimeFilter
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeWithAggregatesFilter
	notIn: [DateTime!]
}

type Domain {
	createdAt: DateTime!
	deletedAt: DateTime
	description: String!
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type DomainAvgAggregate {
	id: Float
}

input DomainAvgOrderByAggregateInput {
	id: SortOrder
}

type DomainCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	description: Int!
	id: Int!
	name: Int!
	updatedAt: Int!
}

input DomainCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input DomainCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	name: String!
	updatedAt: DateTime
}

input DomainCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	id: Int
	name: String!
	updatedAt: DateTime
}

type DomainGroupBy {
	_avg: DomainAvgAggregate
	_count: DomainCountAggregate
	_max: DomainMaxAggregate
	_min: DomainMinAggregate
	_sum: DomainSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	description: String!
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type DomainMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	id: Int
	name: String
	updatedAt: DateTime
}

input DomainMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

type DomainMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	id: Int
	name: String
	updatedAt: DateTime
}

input DomainMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input DomainOrderByWithAggregationInput {
	_avg: DomainAvgOrderByAggregateInput
	_count: DomainCountOrderByAggregateInput
	_max: DomainMaxOrderByAggregateInput
	_min: DomainMinOrderByAggregateInput
	_sum: DomainSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input DomainOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

enum DomainScalarFieldEnum {
	createdAt
	deletedAt
	description
	id
	name
	updatedAt
}

input DomainScalarWhereWithAggregatesInput {
	AND: [DomainScalarWhereWithAggregatesInput!]
	NOT: [DomainScalarWhereWithAggregatesInput!]
	OR: [DomainScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	description: StringWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type DomainSumAggregate {
	id: Int
}

input DomainSumOrderByAggregateInput {
	id: SortOrder
}

input DomainUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: StringFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input DomainUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: StringFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input DomainWhereInput {
	AND: [DomainWhereInput!]
	NOT: [DomainWhereInput!]
	OR: [DomainWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	description: StringFilter
	id: IntFilter
	name: StringFilter
	updatedAt: DateTimeFilter
}

input DomainWhereUniqueInput {
	id: Int
}

type Education {
	createdAt: DateTime!
	degree: String!
	deletedAt: DateTime
	description: String
	field: String!
	from: DateTime!
	grade: String
	id: Int!
	institute: String!
	to: DateTime
	updatedAt: DateTime!
	user: User!
	userId: Int!
}

type EducationAvgAggregate {
	id: Float
	userId: Float
}

input EducationAvgOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

type EducationCountAggregate {
	_all: Int!
	createdAt: Int!
	degree: Int!
	deletedAt: Int!
	description: Int!
	field: Int!
	from: Int!
	grade: Int!
	id: Int!
	institute: Int!
	to: Int!
	updatedAt: Int!
	userId: Int!
}

input EducationCountOrderByAggregateInput {
	createdAt: SortOrder
	degree: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	field: SortOrder
	from: SortOrder
	grade: SortOrder
	id: SortOrder
	institute: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input EducationCreateInput {
	createdAt: DateTime
	degree: String!
	deletedAt: DateTime
	description: String
	field: String!
	from: DateTime!
	grade: String
	institute: String!
	to: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutEducationInput!
}

input EducationCreateManyInput {
	createdAt: DateTime
	degree: String!
	deletedAt: DateTime
	description: String
	field: String!
	from: DateTime!
	grade: String
	id: Int
	institute: String!
	to: DateTime
	updatedAt: DateTime
	userId: Int!
}

input EducationCreateManyUserInput {
	createdAt: DateTime
	degree: String!
	deletedAt: DateTime
	description: String
	field: String!
	from: DateTime!
	grade: String
	id: Int
	institute: String!
	to: DateTime
	updatedAt: DateTime
}

input EducationCreateManyUserInputEnvelope {
	data: [EducationCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input EducationCreateNestedManyWithoutUserInput {
	connect: [EducationWhereUniqueInput!]
	connectOrCreate: [EducationCreateOrConnectWithoutUserInput!]
	create: [EducationCreateWithoutUserInput!]
	createMany: EducationCreateManyUserInputEnvelope
}

input EducationCreateOrConnectWithoutUserInput {
	create: EducationCreateWithoutUserInput!
	where: EducationWhereUniqueInput!
}

input EducationCreateWithoutUserInput {
	createdAt: DateTime
	degree: String!
	deletedAt: DateTime
	description: String
	field: String!
	from: DateTime!
	grade: String
	institute: String!
	to: DateTime
	updatedAt: DateTime
}

type EducationGroupBy {
	_avg: EducationAvgAggregate
	_count: EducationCountAggregate
	_max: EducationMaxAggregate
	_min: EducationMinAggregate
	_sum: EducationSumAggregate
	createdAt: DateTime!
	degree: String!
	deletedAt: DateTime
	description: String
	field: String!
	from: DateTime!
	grade: String
	id: Int!
	institute: String!
	to: DateTime
	updatedAt: DateTime!
	userId: Int!
}

input EducationListRelationFilter {
	every: EducationWhereInput
	none: EducationWhereInput
	some: EducationWhereInput
}

type EducationMaxAggregate {
	createdAt: DateTime
	degree: String
	deletedAt: DateTime
	description: String
	field: String
	from: DateTime
	grade: String
	id: Int
	institute: String
	to: DateTime
	updatedAt: DateTime
	userId: Int
}

input EducationMaxOrderByAggregateInput {
	createdAt: SortOrder
	degree: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	field: SortOrder
	from: SortOrder
	grade: SortOrder
	id: SortOrder
	institute: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

type EducationMinAggregate {
	createdAt: DateTime
	degree: String
	deletedAt: DateTime
	description: String
	field: String
	from: DateTime
	grade: String
	id: Int
	institute: String
	to: DateTime
	updatedAt: DateTime
	userId: Int
}

input EducationMinOrderByAggregateInput {
	createdAt: SortOrder
	degree: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	field: SortOrder
	from: SortOrder
	grade: SortOrder
	id: SortOrder
	institute: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input EducationOrderByRelationAggregateInput {
	_count: SortOrder
}

input EducationOrderByWithAggregationInput {
	_avg: EducationAvgOrderByAggregateInput
	_count: EducationCountOrderByAggregateInput
	_max: EducationMaxOrderByAggregateInput
	_min: EducationMinOrderByAggregateInput
	_sum: EducationSumOrderByAggregateInput
	createdAt: SortOrder
	degree: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	field: SortOrder
	from: SortOrder
	grade: SortOrder
	id: SortOrder
	institute: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input EducationOrderByWithRelationInput {
	createdAt: SortOrder
	degree: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	field: SortOrder
	from: SortOrder
	grade: SortOrder
	id: SortOrder
	institute: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
}

enum EducationScalarFieldEnum {
	createdAt
	degree
	deletedAt
	description
	field
	from
	grade
	id
	institute
	to
	updatedAt
	userId
}

input EducationScalarWhereInput {
	AND: [EducationScalarWhereInput!]
	NOT: [EducationScalarWhereInput!]
	OR: [EducationScalarWhereInput!]
	createdAt: DateTimeFilter
	degree: StringFilter
	deletedAt: DateTimeNullableFilter
	description: StringNullableFilter
	field: StringFilter
	from: DateTimeFilter
	grade: StringNullableFilter
	id: IntFilter
	institute: StringFilter
	to: DateTimeNullableFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
}

input EducationScalarWhereWithAggregatesInput {
	AND: [EducationScalarWhereWithAggregatesInput!]
	NOT: [EducationScalarWhereWithAggregatesInput!]
	OR: [EducationScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	degree: StringWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	description: StringNullableWithAggregatesFilter
	field: StringWithAggregatesFilter
	from: DateTimeWithAggregatesFilter
	grade: StringNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	institute: StringWithAggregatesFilter
	to: DateTimeNullableWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
}

type EducationSumAggregate {
	id: Int
	userId: Int
}

input EducationSumOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

input EducationUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	degree: StringFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	field: StringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	grade: NullableStringFieldUpdateOperationsInput
	institute: StringFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutEducationInput
}

input EducationUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	degree: StringFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	field: StringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	grade: NullableStringFieldUpdateOperationsInput
	institute: StringFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input EducationUpdateManyWithWhereWithoutUserInput {
	data: EducationUpdateManyMutationInput!
	where: EducationScalarWhereInput!
}

input EducationUpdateManyWithoutUserInput {
	connect: [EducationWhereUniqueInput!]
	connectOrCreate: [EducationCreateOrConnectWithoutUserInput!]
	create: [EducationCreateWithoutUserInput!]
	createMany: EducationCreateManyUserInputEnvelope
	delete: [EducationWhereUniqueInput!]
	deleteMany: [EducationScalarWhereInput!]
	disconnect: [EducationWhereUniqueInput!]
	set: [EducationWhereUniqueInput!]
	update: [EducationUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [EducationUpdateManyWithWhereWithoutUserInput!]
	upsert: [EducationUpsertWithWhereUniqueWithoutUserInput!]
}

input EducationUpdateWithWhereUniqueWithoutUserInput {
	data: EducationUpdateWithoutUserInput!
	where: EducationWhereUniqueInput!
}

input EducationUpdateWithoutUserInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	degree: StringFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	field: StringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	grade: NullableStringFieldUpdateOperationsInput
	institute: StringFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input EducationUpsertWithWhereUniqueWithoutUserInput {
	create: EducationCreateWithoutUserInput!
	update: EducationUpdateWithoutUserInput!
	where: EducationWhereUniqueInput!
}

input EducationWhereInput {
	AND: [EducationWhereInput!]
	NOT: [EducationWhereInput!]
	OR: [EducationWhereInput!]
	createdAt: DateTimeFilter
	degree: StringFilter
	deletedAt: DateTimeNullableFilter
	description: StringNullableFilter
	field: StringFilter
	from: DateTimeFilter
	grade: StringNullableFilter
	id: IntFilter
	institute: StringFilter
	to: DateTimeNullableFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
}

input EducationWhereUniqueInput {
	id: Int
}

type EmploymentType {
	Experience(
		cursor: ExperienceWhereUniqueInput
		distinct: [ExperienceScalarFieldEnum!]
		orderBy: [ExperienceOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceWhereInput
	): [Experience!]!
	_count: EmploymentTypeCount
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type EmploymentTypeAvgAggregate {
	id: Float
}

input EmploymentTypeAvgOrderByAggregateInput {
	id: SortOrder
}

type EmploymentTypeCount {
	Experience: Int!
}

type EmploymentTypeCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	name: Int!
	updatedAt: Int!
}

input EmploymentTypeCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input EmploymentTypeCreateInput {
	Experience: ExperienceCreateNestedManyWithoutEmploymentTypeInput
	createdAt: DateTime
	deletedAt: DateTime
	name: String!
	updatedAt: DateTime
}

input EmploymentTypeCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String!
	updatedAt: DateTime
}

input EmploymentTypeCreateNestedOneWithoutExperienceInput {
	connect: EmploymentTypeWhereUniqueInput
	connectOrCreate: EmploymentTypeCreateOrConnectWithoutExperienceInput
	create: EmploymentTypeCreateWithoutExperienceInput
}

input EmploymentTypeCreateOrConnectWithoutExperienceInput {
	create: EmploymentTypeCreateWithoutExperienceInput!
	where: EmploymentTypeWhereUniqueInput!
}

input EmploymentTypeCreateWithoutExperienceInput {
	createdAt: DateTime
	deletedAt: DateTime
	name: String!
	updatedAt: DateTime
}

type EmploymentTypeGroupBy {
	_avg: EmploymentTypeAvgAggregate
	_count: EmploymentTypeCountAggregate
	_max: EmploymentTypeMaxAggregate
	_min: EmploymentTypeMinAggregate
	_sum: EmploymentTypeSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type EmploymentTypeMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input EmploymentTypeMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

type EmploymentTypeMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input EmploymentTypeMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input EmploymentTypeOrderByWithAggregationInput {
	_avg: EmploymentTypeAvgOrderByAggregateInput
	_count: EmploymentTypeCountOrderByAggregateInput
	_max: EmploymentTypeMaxOrderByAggregateInput
	_min: EmploymentTypeMinOrderByAggregateInput
	_sum: EmploymentTypeSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input EmploymentTypeOrderByWithRelationInput {
	Experience: ExperienceOrderByRelationAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input EmploymentTypeRelationFilter {
	is: EmploymentTypeWhereInput
	isNot: EmploymentTypeWhereInput
}

enum EmploymentTypeScalarFieldEnum {
	createdAt
	deletedAt
	id
	name
	updatedAt
}

input EmploymentTypeScalarWhereWithAggregatesInput {
	AND: [EmploymentTypeScalarWhereWithAggregatesInput!]
	NOT: [EmploymentTypeScalarWhereWithAggregatesInput!]
	OR: [EmploymentTypeScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type EmploymentTypeSumAggregate {
	id: Int
}

input EmploymentTypeSumOrderByAggregateInput {
	id: SortOrder
}

input EmploymentTypeUpdateInput {
	Experience: ExperienceUpdateManyWithoutEmploymentTypeInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input EmploymentTypeUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input EmploymentTypeUpdateOneRequiredWithoutExperienceInput {
	connect: EmploymentTypeWhereUniqueInput
	connectOrCreate: EmploymentTypeCreateOrConnectWithoutExperienceInput
	create: EmploymentTypeCreateWithoutExperienceInput
	update: EmploymentTypeUpdateWithoutExperienceInput
	upsert: EmploymentTypeUpsertWithoutExperienceInput
}

input EmploymentTypeUpdateWithoutExperienceInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input EmploymentTypeUpsertWithoutExperienceInput {
	create: EmploymentTypeCreateWithoutExperienceInput!
	update: EmploymentTypeUpdateWithoutExperienceInput!
}

input EmploymentTypeWhereInput {
	AND: [EmploymentTypeWhereInput!]
	Experience: ExperienceListRelationFilter
	NOT: [EmploymentTypeWhereInput!]
	OR: [EmploymentTypeWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	name: StringFilter
	updatedAt: DateTimeFilter
}

input EmploymentTypeWhereUniqueInput {
	id: Int
}

type Experience {
	createdAt: DateTime!
	deletedAt: DateTime
	description: String
	employmentType: EmploymentType!
	employmentTypeId: Int!
	from: DateTime!
	id: Int!
	location: String!
	organization: String!
	role: ExperienceRole!
	roleId: Int!
	to: DateTime
	updatedAt: DateTime!
	user: User!
	userId: Int!
}

type ExperienceAvgAggregate {
	employmentTypeId: Float
	id: Float
	roleId: Float
	userId: Float
}

input ExperienceAvgOrderByAggregateInput {
	employmentTypeId: SortOrder
	id: SortOrder
	roleId: SortOrder
	userId: SortOrder
}

type ExperienceCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	description: Int!
	employmentTypeId: Int!
	from: Int!
	id: Int!
	location: Int!
	organization: Int!
	roleId: Int!
	to: Int!
	updatedAt: Int!
	userId: Int!
}

input ExperienceCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	employmentTypeId: SortOrder
	from: SortOrder
	id: SortOrder
	location: SortOrder
	organization: SortOrder
	roleId: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ExperienceCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentType: EmploymentTypeCreateNestedOneWithoutExperienceInput!
	from: DateTime!
	location: String!
	organization: String!
	role: ExperienceRoleCreateNestedOneWithoutExperienceInput!
	to: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutExperienceInput!
}

input ExperienceCreateManyEmploymentTypeInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	from: DateTime!
	id: Int
	location: String!
	organization: String!
	roleId: Int!
	to: DateTime
	updatedAt: DateTime
	userId: Int!
}

input ExperienceCreateManyEmploymentTypeInputEnvelope {
	data: [ExperienceCreateManyEmploymentTypeInput!]!
	skipDuplicates: Boolean
}

input ExperienceCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentTypeId: Int!
	from: DateTime!
	id: Int
	location: String!
	organization: String!
	roleId: Int!
	to: DateTime
	updatedAt: DateTime
	userId: Int!
}

input ExperienceCreateManyRoleInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentTypeId: Int!
	from: DateTime!
	id: Int
	location: String!
	organization: String!
	to: DateTime
	updatedAt: DateTime
	userId: Int!
}

input ExperienceCreateManyRoleInputEnvelope {
	data: [ExperienceCreateManyRoleInput!]!
	skipDuplicates: Boolean
}

input ExperienceCreateManyUserInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentTypeId: Int!
	from: DateTime!
	id: Int
	location: String!
	organization: String!
	roleId: Int!
	to: DateTime
	updatedAt: DateTime
}

input ExperienceCreateManyUserInputEnvelope {
	data: [ExperienceCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input ExperienceCreateNestedManyWithoutEmploymentTypeInput {
	connect: [ExperienceWhereUniqueInput!]
	connectOrCreate: [ExperienceCreateOrConnectWithoutEmploymentTypeInput!]
	create: [ExperienceCreateWithoutEmploymentTypeInput!]
	createMany: ExperienceCreateManyEmploymentTypeInputEnvelope
}

input ExperienceCreateNestedManyWithoutRoleInput {
	connect: [ExperienceWhereUniqueInput!]
	connectOrCreate: [ExperienceCreateOrConnectWithoutRoleInput!]
	create: [ExperienceCreateWithoutRoleInput!]
	createMany: ExperienceCreateManyRoleInputEnvelope
}

input ExperienceCreateNestedManyWithoutUserInput {
	connect: [ExperienceWhereUniqueInput!]
	connectOrCreate: [ExperienceCreateOrConnectWithoutUserInput!]
	create: [ExperienceCreateWithoutUserInput!]
	createMany: ExperienceCreateManyUserInputEnvelope
}

input ExperienceCreateOrConnectWithoutEmploymentTypeInput {
	create: ExperienceCreateWithoutEmploymentTypeInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceCreateOrConnectWithoutRoleInput {
	create: ExperienceCreateWithoutRoleInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceCreateOrConnectWithoutUserInput {
	create: ExperienceCreateWithoutUserInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceCreateWithoutEmploymentTypeInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	from: DateTime!
	location: String!
	organization: String!
	role: ExperienceRoleCreateNestedOneWithoutExperienceInput!
	to: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutExperienceInput!
}

input ExperienceCreateWithoutRoleInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentType: EmploymentTypeCreateNestedOneWithoutExperienceInput!
	from: DateTime!
	location: String!
	organization: String!
	to: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutExperienceInput!
}

input ExperienceCreateWithoutUserInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentType: EmploymentTypeCreateNestedOneWithoutExperienceInput!
	from: DateTime!
	location: String!
	organization: String!
	role: ExperienceRoleCreateNestedOneWithoutExperienceInput!
	to: DateTime
	updatedAt: DateTime
}

type ExperienceGroupBy {
	_avg: ExperienceAvgAggregate
	_count: ExperienceCountAggregate
	_max: ExperienceMaxAggregate
	_min: ExperienceMinAggregate
	_sum: ExperienceSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	description: String
	employmentTypeId: Int!
	from: DateTime!
	id: Int!
	location: String!
	organization: String!
	roleId: Int!
	to: DateTime
	updatedAt: DateTime!
	userId: Int!
}

input ExperienceListRelationFilter {
	every: ExperienceWhereInput
	none: ExperienceWhereInput
	some: ExperienceWhereInput
}

type ExperienceMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentTypeId: Int
	from: DateTime
	id: Int
	location: String
	organization: String
	roleId: Int
	to: DateTime
	updatedAt: DateTime
	userId: Int
}

input ExperienceMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	employmentTypeId: SortOrder
	from: SortOrder
	id: SortOrder
	location: SortOrder
	organization: SortOrder
	roleId: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

type ExperienceMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	employmentTypeId: Int
	from: DateTime
	id: Int
	location: String
	organization: String
	roleId: Int
	to: DateTime
	updatedAt: DateTime
	userId: Int
}

input ExperienceMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	employmentTypeId: SortOrder
	from: SortOrder
	id: SortOrder
	location: SortOrder
	organization: SortOrder
	roleId: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ExperienceOrderByRelationAggregateInput {
	_count: SortOrder
}

input ExperienceOrderByWithAggregationInput {
	_avg: ExperienceAvgOrderByAggregateInput
	_count: ExperienceCountOrderByAggregateInput
	_max: ExperienceMaxOrderByAggregateInput
	_min: ExperienceMinOrderByAggregateInput
	_sum: ExperienceSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	employmentTypeId: SortOrder
	from: SortOrder
	id: SortOrder
	location: SortOrder
	organization: SortOrder
	roleId: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ExperienceOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	employmentType: EmploymentTypeOrderByWithRelationInput
	employmentTypeId: SortOrder
	from: SortOrder
	id: SortOrder
	location: SortOrder
	organization: SortOrder
	role: ExperienceRoleOrderByWithRelationInput
	roleId: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
}

type ExperienceRole {
	Experience(
		cursor: ExperienceWhereUniqueInput
		distinct: [ExperienceScalarFieldEnum!]
		orderBy: [ExperienceOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceWhereInput
	): [Experience!]!
	_count: ExperienceRoleCount
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type ExperienceRoleAvgAggregate {
	id: Float
}

input ExperienceRoleAvgOrderByAggregateInput {
	id: SortOrder
}

type ExperienceRoleCount {
	Experience: Int!
}

type ExperienceRoleCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	name: Int!
	updatedAt: Int!
}

input ExperienceRoleCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input ExperienceRoleCreateInput {
	Experience: ExperienceCreateNestedManyWithoutRoleInput
	createdAt: DateTime
	deletedAt: DateTime
	name: String!
	updatedAt: DateTime
}

input ExperienceRoleCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String!
	updatedAt: DateTime
}

input ExperienceRoleCreateNestedOneWithoutExperienceInput {
	connect: ExperienceRoleWhereUniqueInput
	connectOrCreate: ExperienceRoleCreateOrConnectWithoutExperienceInput
	create: ExperienceRoleCreateWithoutExperienceInput
}

input ExperienceRoleCreateOrConnectWithoutExperienceInput {
	create: ExperienceRoleCreateWithoutExperienceInput!
	where: ExperienceRoleWhereUniqueInput!
}

input ExperienceRoleCreateWithoutExperienceInput {
	createdAt: DateTime
	deletedAt: DateTime
	name: String!
	updatedAt: DateTime
}

type ExperienceRoleGroupBy {
	_avg: ExperienceRoleAvgAggregate
	_count: ExperienceRoleCountAggregate
	_max: ExperienceRoleMaxAggregate
	_min: ExperienceRoleMinAggregate
	_sum: ExperienceRoleSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type ExperienceRoleMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input ExperienceRoleMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

type ExperienceRoleMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input ExperienceRoleMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input ExperienceRoleOrderByWithAggregationInput {
	_avg: ExperienceRoleAvgOrderByAggregateInput
	_count: ExperienceRoleCountOrderByAggregateInput
	_max: ExperienceRoleMaxOrderByAggregateInput
	_min: ExperienceRoleMinOrderByAggregateInput
	_sum: ExperienceRoleSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input ExperienceRoleOrderByWithRelationInput {
	Experience: ExperienceOrderByRelationAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input ExperienceRoleRelationFilter {
	is: ExperienceRoleWhereInput
	isNot: ExperienceRoleWhereInput
}

enum ExperienceRoleScalarFieldEnum {
	createdAt
	deletedAt
	id
	name
	updatedAt
}

input ExperienceRoleScalarWhereWithAggregatesInput {
	AND: [ExperienceRoleScalarWhereWithAggregatesInput!]
	NOT: [ExperienceRoleScalarWhereWithAggregatesInput!]
	OR: [ExperienceRoleScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type ExperienceRoleSumAggregate {
	id: Int
}

input ExperienceRoleSumOrderByAggregateInput {
	id: SortOrder
}

input ExperienceRoleUpdateInput {
	Experience: ExperienceUpdateManyWithoutRoleInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ExperienceRoleUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ExperienceRoleUpdateOneRequiredWithoutExperienceInput {
	connect: ExperienceRoleWhereUniqueInput
	connectOrCreate: ExperienceRoleCreateOrConnectWithoutExperienceInput
	create: ExperienceRoleCreateWithoutExperienceInput
	update: ExperienceRoleUpdateWithoutExperienceInput
	upsert: ExperienceRoleUpsertWithoutExperienceInput
}

input ExperienceRoleUpdateWithoutExperienceInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ExperienceRoleUpsertWithoutExperienceInput {
	create: ExperienceRoleCreateWithoutExperienceInput!
	update: ExperienceRoleUpdateWithoutExperienceInput!
}

input ExperienceRoleWhereInput {
	AND: [ExperienceRoleWhereInput!]
	Experience: ExperienceListRelationFilter
	NOT: [ExperienceRoleWhereInput!]
	OR: [ExperienceRoleWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	name: StringFilter
	updatedAt: DateTimeFilter
}

input ExperienceRoleWhereUniqueInput {
	id: Int
}

enum ExperienceScalarFieldEnum {
	createdAt
	deletedAt
	description
	employmentTypeId
	from
	id
	location
	organization
	roleId
	to
	updatedAt
	userId
}

input ExperienceScalarWhereInput {
	AND: [ExperienceScalarWhereInput!]
	NOT: [ExperienceScalarWhereInput!]
	OR: [ExperienceScalarWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	description: StringNullableFilter
	employmentTypeId: IntFilter
	from: DateTimeFilter
	id: IntFilter
	location: StringFilter
	organization: StringFilter
	roleId: IntFilter
	to: DateTimeNullableFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
}

input ExperienceScalarWhereWithAggregatesInput {
	AND: [ExperienceScalarWhereWithAggregatesInput!]
	NOT: [ExperienceScalarWhereWithAggregatesInput!]
	OR: [ExperienceScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	description: StringNullableWithAggregatesFilter
	employmentTypeId: IntWithAggregatesFilter
	from: DateTimeWithAggregatesFilter
	id: IntWithAggregatesFilter
	location: StringWithAggregatesFilter
	organization: StringWithAggregatesFilter
	roleId: IntWithAggregatesFilter
	to: DateTimeNullableWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
}

type ExperienceSumAggregate {
	employmentTypeId: Int
	id: Int
	roleId: Int
	userId: Int
}

input ExperienceSumOrderByAggregateInput {
	employmentTypeId: SortOrder
	id: SortOrder
	roleId: SortOrder
	userId: SortOrder
}

input ExperienceUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	employmentType: EmploymentTypeUpdateOneRequiredWithoutExperienceInput
	from: DateTimeFieldUpdateOperationsInput
	location: StringFieldUpdateOperationsInput
	organization: StringFieldUpdateOperationsInput
	role: ExperienceRoleUpdateOneRequiredWithoutExperienceInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutExperienceInput
}

input ExperienceUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	location: StringFieldUpdateOperationsInput
	organization: StringFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ExperienceUpdateManyWithWhereWithoutEmploymentTypeInput {
	data: ExperienceUpdateManyMutationInput!
	where: ExperienceScalarWhereInput!
}

input ExperienceUpdateManyWithWhereWithoutRoleInput {
	data: ExperienceUpdateManyMutationInput!
	where: ExperienceScalarWhereInput!
}

input ExperienceUpdateManyWithWhereWithoutUserInput {
	data: ExperienceUpdateManyMutationInput!
	where: ExperienceScalarWhereInput!
}

input ExperienceUpdateManyWithoutEmploymentTypeInput {
	connect: [ExperienceWhereUniqueInput!]
	connectOrCreate: [ExperienceCreateOrConnectWithoutEmploymentTypeInput!]
	create: [ExperienceCreateWithoutEmploymentTypeInput!]
	createMany: ExperienceCreateManyEmploymentTypeInputEnvelope
	delete: [ExperienceWhereUniqueInput!]
	deleteMany: [ExperienceScalarWhereInput!]
	disconnect: [ExperienceWhereUniqueInput!]
	set: [ExperienceWhereUniqueInput!]
	update: [ExperienceUpdateWithWhereUniqueWithoutEmploymentTypeInput!]
	updateMany: [ExperienceUpdateManyWithWhereWithoutEmploymentTypeInput!]
	upsert: [ExperienceUpsertWithWhereUniqueWithoutEmploymentTypeInput!]
}

input ExperienceUpdateManyWithoutRoleInput {
	connect: [ExperienceWhereUniqueInput!]
	connectOrCreate: [ExperienceCreateOrConnectWithoutRoleInput!]
	create: [ExperienceCreateWithoutRoleInput!]
	createMany: ExperienceCreateManyRoleInputEnvelope
	delete: [ExperienceWhereUniqueInput!]
	deleteMany: [ExperienceScalarWhereInput!]
	disconnect: [ExperienceWhereUniqueInput!]
	set: [ExperienceWhereUniqueInput!]
	update: [ExperienceUpdateWithWhereUniqueWithoutRoleInput!]
	updateMany: [ExperienceUpdateManyWithWhereWithoutRoleInput!]
	upsert: [ExperienceUpsertWithWhereUniqueWithoutRoleInput!]
}

input ExperienceUpdateManyWithoutUserInput {
	connect: [ExperienceWhereUniqueInput!]
	connectOrCreate: [ExperienceCreateOrConnectWithoutUserInput!]
	create: [ExperienceCreateWithoutUserInput!]
	createMany: ExperienceCreateManyUserInputEnvelope
	delete: [ExperienceWhereUniqueInput!]
	deleteMany: [ExperienceScalarWhereInput!]
	disconnect: [ExperienceWhereUniqueInput!]
	set: [ExperienceWhereUniqueInput!]
	update: [ExperienceUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [ExperienceUpdateManyWithWhereWithoutUserInput!]
	upsert: [ExperienceUpsertWithWhereUniqueWithoutUserInput!]
}

input ExperienceUpdateWithWhereUniqueWithoutEmploymentTypeInput {
	data: ExperienceUpdateWithoutEmploymentTypeInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceUpdateWithWhereUniqueWithoutRoleInput {
	data: ExperienceUpdateWithoutRoleInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceUpdateWithWhereUniqueWithoutUserInput {
	data: ExperienceUpdateWithoutUserInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceUpdateWithoutEmploymentTypeInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	location: StringFieldUpdateOperationsInput
	organization: StringFieldUpdateOperationsInput
	role: ExperienceRoleUpdateOneRequiredWithoutExperienceInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutExperienceInput
}

input ExperienceUpdateWithoutRoleInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	employmentType: EmploymentTypeUpdateOneRequiredWithoutExperienceInput
	from: DateTimeFieldUpdateOperationsInput
	location: StringFieldUpdateOperationsInput
	organization: StringFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutExperienceInput
}

input ExperienceUpdateWithoutUserInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: NullableStringFieldUpdateOperationsInput
	employmentType: EmploymentTypeUpdateOneRequiredWithoutExperienceInput
	from: DateTimeFieldUpdateOperationsInput
	location: StringFieldUpdateOperationsInput
	organization: StringFieldUpdateOperationsInput
	role: ExperienceRoleUpdateOneRequiredWithoutExperienceInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ExperienceUpsertWithWhereUniqueWithoutEmploymentTypeInput {
	create: ExperienceCreateWithoutEmploymentTypeInput!
	update: ExperienceUpdateWithoutEmploymentTypeInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceUpsertWithWhereUniqueWithoutRoleInput {
	create: ExperienceCreateWithoutRoleInput!
	update: ExperienceUpdateWithoutRoleInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceUpsertWithWhereUniqueWithoutUserInput {
	create: ExperienceCreateWithoutUserInput!
	update: ExperienceUpdateWithoutUserInput!
	where: ExperienceWhereUniqueInput!
}

input ExperienceWhereInput {
	AND: [ExperienceWhereInput!]
	NOT: [ExperienceWhereInput!]
	OR: [ExperienceWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	description: StringNullableFilter
	employmentType: EmploymentTypeRelationFilter
	employmentTypeId: IntFilter
	from: DateTimeFilter
	id: IntFilter
	location: StringFilter
	organization: StringFilter
	role: ExperienceRoleRelationFilter
	roleId: IntFilter
	to: DateTimeNullableFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
}

input ExperienceWhereUniqueInput {
	id: Int
}

input FloatNullableFilter {
	equals: Float
	gt: Float
	gte: Float
	in: [Float!]
	lt: Float
	lte: Float
	not: NestedFloatNullableFilter
	notIn: [Float!]
}

input FloatNullableWithAggregatesFilter {
	_avg: NestedFloatNullableFilter
	_count: NestedIntNullableFilter
	_max: NestedFloatNullableFilter
	_min: NestedFloatNullableFilter
	_sum: NestedFloatNullableFilter
	equals: Float
	gt: Float
	gte: Float
	in: [Float!]
	lt: Float
	lte: Float
	not: NestedFloatNullableWithAggregatesFilter
	notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
	decrement: Int
	divide: Int
	increment: Int
	multiply: Int
	set: Int
}

input IntFilter {
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntFilter
	notIn: [Int!]
}

input IntNullableFilter {
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntNullableFilter
	notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
	_avg: NestedFloatNullableFilter
	_count: NestedIntNullableFilter
	_max: NestedIntNullableFilter
	_min: NestedIntNullableFilter
	_sum: NestedIntNullableFilter
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntNullableWithAggregatesFilter
	notIn: [Int!]
}

input IntWithAggregatesFilter {
	_avg: NestedFloatFilter
	_count: NestedIntFilter
	_max: NestedIntFilter
	_min: NestedIntFilter
	_sum: NestedIntFilter
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntWithAggregatesFilter
	notIn: [Int!]
}

type Invitation {
	code: String!
	createdAt: DateTime!
	createdBy: User!
	createdById: Int!
	deletedAt: DateTime
	id: Int!
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	recepientUser: User!
	recepientUserId: Int!
	updatedAt: DateTime!
}

type InvitationAvgAggregate {
	createdById: Float
	id: Float
	invitedToId: Float
	recepientUserId: Float
}

input InvitationAvgOrderByAggregateInput {
	createdById: SortOrder
	id: SortOrder
	invitedToId: SortOrder
	recepientUserId: SortOrder
}

type InvitationCountAggregate {
	_all: Int!
	code: Int!
	createdAt: Int!
	createdById: Int!
	deletedAt: Int!
	id: Int!
	invitedToEntity: Int!
	invitedToId: Int!
	isAccepted: Int!
	isFirsttime: Int!
	isRejected: Int!
	message: Int!
	recepientUserId: Int!
	updatedAt: Int!
}

input InvitationCountOrderByAggregateInput {
	code: SortOrder
	createdAt: SortOrder
	createdById: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	invitedToEntity: SortOrder
	invitedToId: SortOrder
	isAccepted: SortOrder
	isFirsttime: SortOrder
	isRejected: SortOrder
	message: SortOrder
	recepientUserId: SortOrder
	updatedAt: SortOrder
}

input InvitationCreateInput {
	code: String!
	createdAt: DateTime
	createdBy: UserCreateNestedOneWithoutInvitationsSentInput!
	deletedAt: DateTime
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	recepientUser: UserCreateNestedOneWithoutInvitationsReceivedInput!
	updatedAt: DateTime
}

input InvitationCreateManyCreatedByInput {
	code: String!
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	recepientUserId: Int!
	updatedAt: DateTime
}

input InvitationCreateManyCreatedByInputEnvelope {
	data: [InvitationCreateManyCreatedByInput!]!
	skipDuplicates: Boolean
}

input InvitationCreateManyInput {
	code: String!
	createdAt: DateTime
	createdById: Int!
	deletedAt: DateTime
	id: Int
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	recepientUserId: Int!
	updatedAt: DateTime
}

input InvitationCreateManyRecepientUserInput {
	code: String!
	createdAt: DateTime
	createdById: Int!
	deletedAt: DateTime
	id: Int
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	updatedAt: DateTime
}

input InvitationCreateManyRecepientUserInputEnvelope {
	data: [InvitationCreateManyRecepientUserInput!]!
	skipDuplicates: Boolean
}

input InvitationCreateNestedManyWithoutCreatedByInput {
	connect: [InvitationWhereUniqueInput!]
	connectOrCreate: [InvitationCreateOrConnectWithoutCreatedByInput!]
	create: [InvitationCreateWithoutCreatedByInput!]
	createMany: InvitationCreateManyCreatedByInputEnvelope
}

input InvitationCreateNestedManyWithoutRecepientUserInput {
	connect: [InvitationWhereUniqueInput!]
	connectOrCreate: [InvitationCreateOrConnectWithoutRecepientUserInput!]
	create: [InvitationCreateWithoutRecepientUserInput!]
	createMany: InvitationCreateManyRecepientUserInputEnvelope
}

input InvitationCreateOrConnectWithoutCreatedByInput {
	create: InvitationCreateWithoutCreatedByInput!
	where: InvitationWhereUniqueInput!
}

input InvitationCreateOrConnectWithoutRecepientUserInput {
	create: InvitationCreateWithoutRecepientUserInput!
	where: InvitationWhereUniqueInput!
}

input InvitationCreateWithoutCreatedByInput {
	code: String!
	createdAt: DateTime
	deletedAt: DateTime
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	recepientUser: UserCreateNestedOneWithoutInvitationsReceivedInput!
	updatedAt: DateTime
}

input InvitationCreateWithoutRecepientUserInput {
	code: String!
	createdAt: DateTime
	createdBy: UserCreateNestedOneWithoutInvitationsSentInput!
	deletedAt: DateTime
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	updatedAt: DateTime
}

type InvitationGroupBy {
	_avg: InvitationAvgAggregate
	_count: InvitationCountAggregate
	_max: InvitationMaxAggregate
	_min: InvitationMinAggregate
	_sum: InvitationSumAggregate
	code: String!
	createdAt: DateTime!
	createdById: Int!
	deletedAt: DateTime
	id: Int!
	invitedToEntity: String!
	invitedToId: Int!
	isAccepted: Boolean!
	isFirsttime: Boolean!
	isRejected: Boolean!
	message: String!
	recepientUserId: Int!
	updatedAt: DateTime!
}

input InvitationListRelationFilter {
	every: InvitationWhereInput
	none: InvitationWhereInput
	some: InvitationWhereInput
}

type InvitationMaxAggregate {
	code: String
	createdAt: DateTime
	createdById: Int
	deletedAt: DateTime
	id: Int
	invitedToEntity: String
	invitedToId: Int
	isAccepted: Boolean
	isFirsttime: Boolean
	isRejected: Boolean
	message: String
	recepientUserId: Int
	updatedAt: DateTime
}

input InvitationMaxOrderByAggregateInput {
	code: SortOrder
	createdAt: SortOrder
	createdById: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	invitedToEntity: SortOrder
	invitedToId: SortOrder
	isAccepted: SortOrder
	isFirsttime: SortOrder
	isRejected: SortOrder
	message: SortOrder
	recepientUserId: SortOrder
	updatedAt: SortOrder
}

type InvitationMinAggregate {
	code: String
	createdAt: DateTime
	createdById: Int
	deletedAt: DateTime
	id: Int
	invitedToEntity: String
	invitedToId: Int
	isAccepted: Boolean
	isFirsttime: Boolean
	isRejected: Boolean
	message: String
	recepientUserId: Int
	updatedAt: DateTime
}

input InvitationMinOrderByAggregateInput {
	code: SortOrder
	createdAt: SortOrder
	createdById: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	invitedToEntity: SortOrder
	invitedToId: SortOrder
	isAccepted: SortOrder
	isFirsttime: SortOrder
	isRejected: SortOrder
	message: SortOrder
	recepientUserId: SortOrder
	updatedAt: SortOrder
}

input InvitationOrderByRelationAggregateInput {
	_count: SortOrder
}

input InvitationOrderByWithAggregationInput {
	_avg: InvitationAvgOrderByAggregateInput
	_count: InvitationCountOrderByAggregateInput
	_max: InvitationMaxOrderByAggregateInput
	_min: InvitationMinOrderByAggregateInput
	_sum: InvitationSumOrderByAggregateInput
	code: SortOrder
	createdAt: SortOrder
	createdById: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	invitedToEntity: SortOrder
	invitedToId: SortOrder
	isAccepted: SortOrder
	isFirsttime: SortOrder
	isRejected: SortOrder
	message: SortOrder
	recepientUserId: SortOrder
	updatedAt: SortOrder
}

input InvitationOrderByWithRelationInput {
	code: SortOrder
	createdAt: SortOrder
	createdBy: UserOrderByWithRelationInput
	createdById: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	invitedToEntity: SortOrder
	invitedToId: SortOrder
	isAccepted: SortOrder
	isFirsttime: SortOrder
	isRejected: SortOrder
	message: SortOrder
	recepientUser: UserOrderByWithRelationInput
	recepientUserId: SortOrder
	updatedAt: SortOrder
}

enum InvitationScalarFieldEnum {
	code
	createdAt
	createdById
	deletedAt
	id
	invitedToEntity
	invitedToId
	isAccepted
	isFirsttime
	isRejected
	message
	recepientUserId
	updatedAt
}

input InvitationScalarWhereInput {
	AND: [InvitationScalarWhereInput!]
	NOT: [InvitationScalarWhereInput!]
	OR: [InvitationScalarWhereInput!]
	code: StringFilter
	createdAt: DateTimeFilter
	createdById: IntFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	invitedToEntity: StringFilter
	invitedToId: IntFilter
	isAccepted: BoolFilter
	isFirsttime: BoolFilter
	isRejected: BoolFilter
	message: StringFilter
	recepientUserId: IntFilter
	updatedAt: DateTimeFilter
}

input InvitationScalarWhereWithAggregatesInput {
	AND: [InvitationScalarWhereWithAggregatesInput!]
	NOT: [InvitationScalarWhereWithAggregatesInput!]
	OR: [InvitationScalarWhereWithAggregatesInput!]
	code: StringWithAggregatesFilter
	createdAt: DateTimeWithAggregatesFilter
	createdById: IntWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	invitedToEntity: StringWithAggregatesFilter
	invitedToId: IntWithAggregatesFilter
	isAccepted: BoolWithAggregatesFilter
	isFirsttime: BoolWithAggregatesFilter
	isRejected: BoolWithAggregatesFilter
	message: StringWithAggregatesFilter
	recepientUserId: IntWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type InvitationSumAggregate {
	createdById: Int
	id: Int
	invitedToId: Int
	recepientUserId: Int
}

input InvitationSumOrderByAggregateInput {
	createdById: SortOrder
	id: SortOrder
	invitedToId: SortOrder
	recepientUserId: SortOrder
}

input InvitationUpdateInput {
	code: StringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	createdBy: UserUpdateOneRequiredWithoutInvitationsSentInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	invitedToEntity: StringFieldUpdateOperationsInput
	invitedToId: IntFieldUpdateOperationsInput
	isAccepted: BoolFieldUpdateOperationsInput
	isFirsttime: BoolFieldUpdateOperationsInput
	isRejected: BoolFieldUpdateOperationsInput
	message: StringFieldUpdateOperationsInput
	recepientUser: UserUpdateOneRequiredWithoutInvitationsReceivedInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input InvitationUpdateManyMutationInput {
	code: StringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	invitedToEntity: StringFieldUpdateOperationsInput
	invitedToId: IntFieldUpdateOperationsInput
	isAccepted: BoolFieldUpdateOperationsInput
	isFirsttime: BoolFieldUpdateOperationsInput
	isRejected: BoolFieldUpdateOperationsInput
	message: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input InvitationUpdateManyWithWhereWithoutCreatedByInput {
	data: InvitationUpdateManyMutationInput!
	where: InvitationScalarWhereInput!
}

input InvitationUpdateManyWithWhereWithoutRecepientUserInput {
	data: InvitationUpdateManyMutationInput!
	where: InvitationScalarWhereInput!
}

input InvitationUpdateManyWithoutCreatedByInput {
	connect: [InvitationWhereUniqueInput!]
	connectOrCreate: [InvitationCreateOrConnectWithoutCreatedByInput!]
	create: [InvitationCreateWithoutCreatedByInput!]
	createMany: InvitationCreateManyCreatedByInputEnvelope
	delete: [InvitationWhereUniqueInput!]
	deleteMany: [InvitationScalarWhereInput!]
	disconnect: [InvitationWhereUniqueInput!]
	set: [InvitationWhereUniqueInput!]
	update: [InvitationUpdateWithWhereUniqueWithoutCreatedByInput!]
	updateMany: [InvitationUpdateManyWithWhereWithoutCreatedByInput!]
	upsert: [InvitationUpsertWithWhereUniqueWithoutCreatedByInput!]
}

input InvitationUpdateManyWithoutRecepientUserInput {
	connect: [InvitationWhereUniqueInput!]
	connectOrCreate: [InvitationCreateOrConnectWithoutRecepientUserInput!]
	create: [InvitationCreateWithoutRecepientUserInput!]
	createMany: InvitationCreateManyRecepientUserInputEnvelope
	delete: [InvitationWhereUniqueInput!]
	deleteMany: [InvitationScalarWhereInput!]
	disconnect: [InvitationWhereUniqueInput!]
	set: [InvitationWhereUniqueInput!]
	update: [InvitationUpdateWithWhereUniqueWithoutRecepientUserInput!]
	updateMany: [InvitationUpdateManyWithWhereWithoutRecepientUserInput!]
	upsert: [InvitationUpsertWithWhereUniqueWithoutRecepientUserInput!]
}

input InvitationUpdateWithWhereUniqueWithoutCreatedByInput {
	data: InvitationUpdateWithoutCreatedByInput!
	where: InvitationWhereUniqueInput!
}

input InvitationUpdateWithWhereUniqueWithoutRecepientUserInput {
	data: InvitationUpdateWithoutRecepientUserInput!
	where: InvitationWhereUniqueInput!
}

input InvitationUpdateWithoutCreatedByInput {
	code: StringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	invitedToEntity: StringFieldUpdateOperationsInput
	invitedToId: IntFieldUpdateOperationsInput
	isAccepted: BoolFieldUpdateOperationsInput
	isFirsttime: BoolFieldUpdateOperationsInput
	isRejected: BoolFieldUpdateOperationsInput
	message: StringFieldUpdateOperationsInput
	recepientUser: UserUpdateOneRequiredWithoutInvitationsReceivedInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input InvitationUpdateWithoutRecepientUserInput {
	code: StringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	createdBy: UserUpdateOneRequiredWithoutInvitationsSentInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	invitedToEntity: StringFieldUpdateOperationsInput
	invitedToId: IntFieldUpdateOperationsInput
	isAccepted: BoolFieldUpdateOperationsInput
	isFirsttime: BoolFieldUpdateOperationsInput
	isRejected: BoolFieldUpdateOperationsInput
	message: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input InvitationUpsertWithWhereUniqueWithoutCreatedByInput {
	create: InvitationCreateWithoutCreatedByInput!
	update: InvitationUpdateWithoutCreatedByInput!
	where: InvitationWhereUniqueInput!
}

input InvitationUpsertWithWhereUniqueWithoutRecepientUserInput {
	create: InvitationCreateWithoutRecepientUserInput!
	update: InvitationUpdateWithoutRecepientUserInput!
	where: InvitationWhereUniqueInput!
}

input InvitationWhereInput {
	AND: [InvitationWhereInput!]
	NOT: [InvitationWhereInput!]
	OR: [InvitationWhereInput!]
	code: StringFilter
	createdAt: DateTimeFilter
	createdBy: UserRelationFilter
	createdById: IntFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	invitedToEntity: StringFilter
	invitedToId: IntFilter
	isAccepted: BoolFilter
	isFirsttime: BoolFilter
	isRejected: BoolFilter
	message: StringFilter
	recepientUser: UserRelationFilter
	recepientUserId: IntFilter
	updatedAt: DateTimeFilter
}

input InvitationWhereUniqueInput {
	id: Int
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
	@specifiedBy(
		url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
	)

input JsonNullableFilter {
	equals: JSON
	not: JSON
}

input JsonNullableWithAggregatesFilter {
	_count: NestedIntNullableFilter
	_max: NestedJsonNullableFilter
	_min: NestedJsonNullableFilter
	equals: JSON
	not: JSON
}

input LoginInput {
	email: String!
	password: String!
}

type MessageResponse {
	message: String!
	success: Boolean!
}

type Mutation {
	createActivity(data: ActivityCreateInput!): Activity!
	createAddress(data: AddressCreateInput!): Address!
	createComment(data: CommentCreateInput!): Comment!
	createCountry(data: CountryCreateInput!): Country!
	createDomain(data: DomainCreateInput!): Domain!
	createEducation(data: EducationCreateInput!): Education!
	createEmploymentType(data: EmploymentTypeCreateInput!): EmploymentType!
	createExperience(data: ExperienceCreateInput!): Experience!
	createExperienceRole(data: ExperienceRoleCreateInput!): ExperienceRole!
	createInvitation(data: InvitationCreateInput!): Invitation!
	createManyActivity(
		data: [ActivityCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyAddress(
		data: [AddressCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyComment(
		data: [CommentCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyCountry(
		data: [CountryCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyDomain(
		data: [DomainCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyEducation(
		data: [EducationCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyEmploymentType(
		data: [EmploymentTypeCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyExperience(
		data: [ExperienceCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyExperienceRole(
		data: [ExperienceRoleCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyInvitation(
		data: [InvitationCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyPost(
		data: [PostCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyProfile(
		data: [ProfileCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyProject(
		data: [ProjectCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyRole(
		data: [RoleCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyScircle(
		data: [ScircleCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManySkill(
		data: [SkillCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyToken(
		data: [TokenCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyUser(
		data: [UserCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyUserProject(
		data: [UserProjectCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyUserProjectRole(
		data: [UserProjectRoleCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createManyUserRoleMapping(
		data: [UserRoleMappingCreateManyInput!]!
		skipDuplicates: Boolean
	): AffectedRowsOutput!
	createPost(data: PostCreateInput!): Post!
	createProfile(data: ProfileCreateInput!): Profile!
	createProject(data: ProjectCreateInput!): Project!
	createRole(data: RoleCreateInput!): Role!
	createScircle(data: ScircleCreateInput!): Scircle!
	createSkill(data: SkillCreateInput!): Skill!
	createToken(data: TokenCreateInput!): Token!
	createUser(data: UserCreateInput!): User!
	createUserProject(data: UserProjectCreateInput!): UserProject!
	createUserProjectRole(data: UserProjectRoleCreateInput!): UserProjectRole!
	createUserRoleMapping(data: UserRoleMappingCreateInput!): UserRoleMapping!
	deleteActivity(where: ActivityWhereUniqueInput!): Activity
	deleteAddress(where: AddressWhereUniqueInput!): Address
	deleteComment(where: CommentWhereUniqueInput!): Comment
	deleteCountry(where: CountryWhereUniqueInput!): Country
	deleteDomain(where: DomainWhereUniqueInput!): Domain
	deleteEducation(where: EducationWhereUniqueInput!): Education
	deleteEmploymentType(where: EmploymentTypeWhereUniqueInput!): EmploymentType
	deleteExperience(where: ExperienceWhereUniqueInput!): Experience
	deleteExperienceRole(where: ExperienceRoleWhereUniqueInput!): ExperienceRole
	deleteInvitation(where: InvitationWhereUniqueInput!): Invitation
	deleteManyActivity(where: ActivityWhereInput): AffectedRowsOutput!
	deleteManyAddress(where: AddressWhereInput): AffectedRowsOutput!
	deleteManyComment(where: CommentWhereInput): AffectedRowsOutput!
	deleteManyCountry(where: CountryWhereInput): AffectedRowsOutput!
	deleteManyDomain(where: DomainWhereInput): AffectedRowsOutput!
	deleteManyEducation(where: EducationWhereInput): AffectedRowsOutput!
	deleteManyEmploymentType(where: EmploymentTypeWhereInput): AffectedRowsOutput!
	deleteManyExperience(where: ExperienceWhereInput): AffectedRowsOutput!
	deleteManyExperienceRole(where: ExperienceRoleWhereInput): AffectedRowsOutput!
	deleteManyInvitation(where: InvitationWhereInput): AffectedRowsOutput!
	deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
	deleteManyProfile(where: ProfileWhereInput): AffectedRowsOutput!
	deleteManyProject(where: ProjectWhereInput): AffectedRowsOutput!
	deleteManyRole(where: RoleWhereInput): AffectedRowsOutput!
	deleteManyScircle(where: ScircleWhereInput): AffectedRowsOutput!
	deleteManySkill(where: SkillWhereInput): AffectedRowsOutput!
	deleteManyToken(where: TokenWhereInput): AffectedRowsOutput!
	deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
	deleteManyUserProject(where: UserProjectWhereInput): AffectedRowsOutput!
	deleteManyUserProjectRole(
		where: UserProjectRoleWhereInput
	): AffectedRowsOutput!
	deleteManyUserRoleMapping(
		where: UserRoleMappingWhereInput
	): AffectedRowsOutput!
	deletePost(where: PostWhereUniqueInput!): Post
	deleteProfile(where: ProfileWhereUniqueInput!): Profile
	deleteProject(where: ProjectWhereUniqueInput!): Project
	deleteRole(where: RoleWhereUniqueInput!): Role
	deleteScircle(where: ScircleWhereUniqueInput!): Scircle
	deleteSkill(where: SkillWhereUniqueInput!): Skill
	deleteToken(where: TokenWhereUniqueInput!): Token
	deleteUser(where: UserWhereUniqueInput!): User
	deleteUserProject(where: UserProjectWhereUniqueInput!): UserProject
	deleteUserProjectRole(
		where: UserProjectRoleWhereUniqueInput!
	): UserProjectRole
	deleteUserRoleMapping(
		where: UserRoleMappingWhereUniqueInput!
	): UserRoleMapping
	forgotPassword(email: String!): MessageResponse!
	login(data: LoginInput!): AccessTokenOutput!
	register(data: RegistrationInput!): MessageResponse!
	resetPassword(password: String!, token: String!): MessageResponse!
	signInWithLinkendIn: SignInWithLinkendInOutput!
	updateActivity(
		data: ActivityUpdateInput!
		where: ActivityWhereUniqueInput!
	): Activity
	updateAddress(
		data: AddressUpdateInput!
		where: AddressWhereUniqueInput!
	): Address
	updateComment(
		data: CommentUpdateInput!
		where: CommentWhereUniqueInput!
	): Comment
	updateCountry(
		data: CountryUpdateInput!
		where: CountryWhereUniqueInput!
	): Country
	updateDomain(data: DomainUpdateInput!, where: DomainWhereUniqueInput!): Domain
	updateEducation(
		data: EducationUpdateInput!
		where: EducationWhereUniqueInput!
	): Education
	updateEmploymentType(
		data: EmploymentTypeUpdateInput!
		where: EmploymentTypeWhereUniqueInput!
	): EmploymentType
	updateExperience(
		data: ExperienceUpdateInput!
		where: ExperienceWhereUniqueInput!
	): Experience
	updateExperienceRole(
		data: ExperienceRoleUpdateInput!
		where: ExperienceRoleWhereUniqueInput!
	): ExperienceRole
	updateInvitation(
		data: InvitationUpdateInput!
		where: InvitationWhereUniqueInput!
	): Invitation
	updateManyActivity(
		data: ActivityUpdateManyMutationInput!
		where: ActivityWhereInput
	): AffectedRowsOutput!
	updateManyAddress(
		data: AddressUpdateManyMutationInput!
		where: AddressWhereInput
	): AffectedRowsOutput!
	updateManyComment(
		data: CommentUpdateManyMutationInput!
		where: CommentWhereInput
	): AffectedRowsOutput!
	updateManyCountry(
		data: CountryUpdateManyMutationInput!
		where: CountryWhereInput
	): AffectedRowsOutput!
	updateManyDomain(
		data: DomainUpdateManyMutationInput!
		where: DomainWhereInput
	): AffectedRowsOutput!
	updateManyEducation(
		data: EducationUpdateManyMutationInput!
		where: EducationWhereInput
	): AffectedRowsOutput!
	updateManyEmploymentType(
		data: EmploymentTypeUpdateManyMutationInput!
		where: EmploymentTypeWhereInput
	): AffectedRowsOutput!
	updateManyExperience(
		data: ExperienceUpdateManyMutationInput!
		where: ExperienceWhereInput
	): AffectedRowsOutput!
	updateManyExperienceRole(
		data: ExperienceRoleUpdateManyMutationInput!
		where: ExperienceRoleWhereInput
	): AffectedRowsOutput!
	updateManyInvitation(
		data: InvitationUpdateManyMutationInput!
		where: InvitationWhereInput
	): AffectedRowsOutput!
	updateManyPost(
		data: PostUpdateManyMutationInput!
		where: PostWhereInput
	): AffectedRowsOutput!
	updateManyProfile(
		data: ProfileUpdateManyMutationInput!
		where: ProfileWhereInput
	): AffectedRowsOutput!
	updateManyProject(
		data: ProjectUpdateManyMutationInput!
		where: ProjectWhereInput
	): AffectedRowsOutput!
	updateManyRole(
		data: RoleUpdateManyMutationInput!
		where: RoleWhereInput
	): AffectedRowsOutput!
	updateManyScircle(
		data: ScircleUpdateManyMutationInput!
		where: ScircleWhereInput
	): AffectedRowsOutput!
	updateManySkill(
		data: SkillUpdateManyMutationInput!
		where: SkillWhereInput
	): AffectedRowsOutput!
	updateManyToken(
		data: TokenUpdateManyMutationInput!
		where: TokenWhereInput
	): AffectedRowsOutput!
	updateManyUser(
		data: UserUpdateManyMutationInput!
		where: UserWhereInput
	): AffectedRowsOutput!
	updateManyUserProject(
		data: UserProjectUpdateManyMutationInput!
		where: UserProjectWhereInput
	): AffectedRowsOutput!
	updateManyUserProjectRole(
		data: UserProjectRoleUpdateManyMutationInput!
		where: UserProjectRoleWhereInput
	): AffectedRowsOutput!
	updateManyUserRoleMapping(
		data: UserRoleMappingUpdateManyMutationInput!
		where: UserRoleMappingWhereInput
	): AffectedRowsOutput!
	updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
	updateProfile(
		data: ProfileUpdateInput!
		where: ProfileWhereUniqueInput!
	): Profile
	updateProject(
		data: ProjectUpdateInput!
		where: ProjectWhereUniqueInput!
	): Project
	updateRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
	updateScircle(
		data: ScircleUpdateInput!
		where: ScircleWhereUniqueInput!
	): Scircle
	updateSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
	updateToken(data: TokenUpdateInput!, where: TokenWhereUniqueInput!): Token
	updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
	updateUserProfile(data: UpdateUserProfileInput!): MessageResponse!
	updateUserProject(
		data: UserProjectUpdateInput!
		where: UserProjectWhereUniqueInput!
	): UserProject
	updateUserProjectRole(
		data: UserProjectRoleUpdateInput!
		where: UserProjectRoleWhereUniqueInput!
	): UserProjectRole
	updateUserRoleMapping(
		data: UserRoleMappingUpdateInput!
		where: UserRoleMappingWhereUniqueInput!
	): UserRoleMapping
	upsertActivity(
		create: ActivityCreateInput!
		update: ActivityUpdateInput!
		where: ActivityWhereUniqueInput!
	): Activity!
	upsertAddress(
		create: AddressCreateInput!
		update: AddressUpdateInput!
		where: AddressWhereUniqueInput!
	): Address!
	upsertComment(
		create: CommentCreateInput!
		update: CommentUpdateInput!
		where: CommentWhereUniqueInput!
	): Comment!
	upsertCountry(
		create: CountryCreateInput!
		update: CountryUpdateInput!
		where: CountryWhereUniqueInput!
	): Country!
	upsertDomain(
		create: DomainCreateInput!
		update: DomainUpdateInput!
		where: DomainWhereUniqueInput!
	): Domain!
	upsertEducation(
		create: EducationCreateInput!
		update: EducationUpdateInput!
		where: EducationWhereUniqueInput!
	): Education!
	upsertEmploymentType(
		create: EmploymentTypeCreateInput!
		update: EmploymentTypeUpdateInput!
		where: EmploymentTypeWhereUniqueInput!
	): EmploymentType!
	upsertExperience(
		create: ExperienceCreateInput!
		update: ExperienceUpdateInput!
		where: ExperienceWhereUniqueInput!
	): Experience!
	upsertExperienceRole(
		create: ExperienceRoleCreateInput!
		update: ExperienceRoleUpdateInput!
		where: ExperienceRoleWhereUniqueInput!
	): ExperienceRole!
	upsertInvitation(
		create: InvitationCreateInput!
		update: InvitationUpdateInput!
		where: InvitationWhereUniqueInput!
	): Invitation!
	upsertPost(
		create: PostCreateInput!
		update: PostUpdateInput!
		where: PostWhereUniqueInput!
	): Post!
	upsertProfile(
		create: ProfileCreateInput!
		update: ProfileUpdateInput!
		where: ProfileWhereUniqueInput!
	): Profile!
	upsertProject(
		create: ProjectCreateInput!
		update: ProjectUpdateInput!
		where: ProjectWhereUniqueInput!
	): Project!
	upsertRole(
		create: RoleCreateInput!
		update: RoleUpdateInput!
		where: RoleWhereUniqueInput!
	): Role!
	upsertScircle(
		create: ScircleCreateInput!
		update: ScircleUpdateInput!
		where: ScircleWhereUniqueInput!
	): Scircle!
	upsertSkill(
		create: SkillCreateInput!
		update: SkillUpdateInput!
		where: SkillWhereUniqueInput!
	): Skill!
	upsertToken(
		create: TokenCreateInput!
		update: TokenUpdateInput!
		where: TokenWhereUniqueInput!
	): Token!
	upsertUser(
		create: UserCreateInput!
		update: UserUpdateInput!
		where: UserWhereUniqueInput!
	): User!
	upsertUserProject(
		create: UserProjectCreateInput!
		update: UserProjectUpdateInput!
		where: UserProjectWhereUniqueInput!
	): UserProject!
	upsertUserProjectRole(
		create: UserProjectRoleCreateInput!
		update: UserProjectRoleUpdateInput!
		where: UserProjectRoleWhereUniqueInput!
	): UserProjectRole!
	upsertUserRoleMapping(
		create: UserRoleMappingCreateInput!
		update: UserRoleMappingUpdateInput!
		where: UserRoleMappingWhereUniqueInput!
	): UserRoleMapping!
}

input NestedBoolFilter {
	equals: Boolean
	not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
	_count: NestedIntFilter
	_max: NestedBoolFilter
	_min: NestedBoolFilter
	equals: Boolean
	not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeFilter
	notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeNullableFilter
	notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
	_count: NestedIntNullableFilter
	_max: NestedDateTimeNullableFilter
	_min: NestedDateTimeNullableFilter
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeNullableWithAggregatesFilter
	notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
	_count: NestedIntFilter
	_max: NestedDateTimeFilter
	_min: NestedDateTimeFilter
	equals: DateTime
	gt: DateTime
	gte: DateTime
	in: [DateTime!]
	lt: DateTime
	lte: DateTime
	not: NestedDateTimeWithAggregatesFilter
	notIn: [DateTime!]
}

input NestedFloatFilter {
	equals: Float
	gt: Float
	gte: Float
	in: [Float!]
	lt: Float
	lte: Float
	not: NestedFloatFilter
	notIn: [Float!]
}

input NestedFloatNullableFilter {
	equals: Float
	gt: Float
	gte: Float
	in: [Float!]
	lt: Float
	lte: Float
	not: NestedFloatNullableFilter
	notIn: [Float!]
}

input NestedFloatNullableWithAggregatesFilter {
	_avg: NestedFloatNullableFilter
	_count: NestedIntNullableFilter
	_max: NestedFloatNullableFilter
	_min: NestedFloatNullableFilter
	_sum: NestedFloatNullableFilter
	equals: Float
	gt: Float
	gte: Float
	in: [Float!]
	lt: Float
	lte: Float
	not: NestedFloatNullableWithAggregatesFilter
	notIn: [Float!]
}

input NestedIntFilter {
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntFilter
	notIn: [Int!]
}

input NestedIntNullableFilter {
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntNullableFilter
	notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
	_avg: NestedFloatNullableFilter
	_count: NestedIntNullableFilter
	_max: NestedIntNullableFilter
	_min: NestedIntNullableFilter
	_sum: NestedIntNullableFilter
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntNullableWithAggregatesFilter
	notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
	_avg: NestedFloatFilter
	_count: NestedIntFilter
	_max: NestedIntFilter
	_min: NestedIntFilter
	_sum: NestedIntFilter
	equals: Int
	gt: Int
	gte: Int
	in: [Int!]
	lt: Int
	lte: Int
	not: NestedIntWithAggregatesFilter
	notIn: [Int!]
}

input NestedJsonNullableFilter {
	equals: JSON
	not: JSON
}

input NestedStringFilter {
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	not: NestedStringFilter
	notIn: [String!]
	startsWith: String
}

input NestedStringNullableFilter {
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	not: NestedStringNullableFilter
	notIn: [String!]
	startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
	_count: NestedIntNullableFilter
	_max: NestedStringNullableFilter
	_min: NestedStringNullableFilter
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	not: NestedStringNullableWithAggregatesFilter
	notIn: [String!]
	startsWith: String
}

input NestedStringWithAggregatesFilter {
	_count: NestedIntFilter
	_max: NestedStringFilter
	_min: NestedStringFilter
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	not: NestedStringWithAggregatesFilter
	notIn: [String!]
	startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
	set: DateTime
}

input NullableFloatFieldUpdateOperationsInput {
	decrement: Float
	divide: Float
	increment: Float
	multiply: Float
	set: Float
}

input NullableIntFieldUpdateOperationsInput {
	decrement: Int
	divide: Int
	increment: Int
	multiply: Int
	set: Int
}

input NullableStringFieldUpdateOperationsInput {
	set: String
}

type Post {
	author: User!
	authorId: Int!
	content: String
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	published: Boolean!
	title: String!
	updatedAt: DateTime!
}

type PostAvgAggregate {
	authorId: Float
	id: Float
}

input PostAvgOrderByAggregateInput {
	authorId: SortOrder
	id: SortOrder
}

type PostCountAggregate {
	_all: Int!
	authorId: Int!
	content: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	published: Int!
	title: Int!
	updatedAt: Int!
}

input PostCountOrderByAggregateInput {
	authorId: SortOrder
	content: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	published: SortOrder
	title: SortOrder
	updatedAt: SortOrder
}

input PostCreateInput {
	author: UserCreateNestedOneWithoutPostInput!
	content: String
	createdAt: DateTime
	deletedAt: DateTime
	published: Boolean
	title: String!
	updatedAt: DateTime
}

input PostCreateManyAuthorInput {
	content: String
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	published: Boolean
	title: String!
	updatedAt: DateTime
}

input PostCreateManyAuthorInputEnvelope {
	data: [PostCreateManyAuthorInput!]!
	skipDuplicates: Boolean
}

input PostCreateManyInput {
	authorId: Int!
	content: String
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	published: Boolean
	title: String!
	updatedAt: DateTime
}

input PostCreateNestedManyWithoutAuthorInput {
	connect: [PostWhereUniqueInput!]
	connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
	create: [PostCreateWithoutAuthorInput!]
	createMany: PostCreateManyAuthorInputEnvelope
}

input PostCreateOrConnectWithoutAuthorInput {
	create: PostCreateWithoutAuthorInput!
	where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
	content: String
	createdAt: DateTime
	deletedAt: DateTime
	published: Boolean
	title: String!
	updatedAt: DateTime
}

type PostGroupBy {
	_avg: PostAvgAggregate
	_count: PostCountAggregate
	_max: PostMaxAggregate
	_min: PostMinAggregate
	_sum: PostSumAggregate
	authorId: Int!
	content: String
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	published: Boolean!
	title: String!
	updatedAt: DateTime!
}

input PostListRelationFilter {
	every: PostWhereInput
	none: PostWhereInput
	some: PostWhereInput
}

type PostMaxAggregate {
	authorId: Int
	content: String
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	published: Boolean
	title: String
	updatedAt: DateTime
}

input PostMaxOrderByAggregateInput {
	authorId: SortOrder
	content: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	published: SortOrder
	title: SortOrder
	updatedAt: SortOrder
}

type PostMinAggregate {
	authorId: Int
	content: String
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	published: Boolean
	title: String
	updatedAt: DateTime
}

input PostMinOrderByAggregateInput {
	authorId: SortOrder
	content: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	published: SortOrder
	title: SortOrder
	updatedAt: SortOrder
}

input PostOrderByRelationAggregateInput {
	_count: SortOrder
}

input PostOrderByWithAggregationInput {
	_avg: PostAvgOrderByAggregateInput
	_count: PostCountOrderByAggregateInput
	_max: PostMaxOrderByAggregateInput
	_min: PostMinOrderByAggregateInput
	_sum: PostSumOrderByAggregateInput
	authorId: SortOrder
	content: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	published: SortOrder
	title: SortOrder
	updatedAt: SortOrder
}

input PostOrderByWithRelationInput {
	author: UserOrderByWithRelationInput
	authorId: SortOrder
	content: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	published: SortOrder
	title: SortOrder
	updatedAt: SortOrder
}

enum PostScalarFieldEnum {
	authorId
	content
	createdAt
	deletedAt
	id
	published
	title
	updatedAt
}

input PostScalarWhereInput {
	AND: [PostScalarWhereInput!]
	NOT: [PostScalarWhereInput!]
	OR: [PostScalarWhereInput!]
	authorId: IntFilter
	content: StringNullableFilter
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	published: BoolFilter
	title: StringFilter
	updatedAt: DateTimeFilter
}

input PostScalarWhereWithAggregatesInput {
	AND: [PostScalarWhereWithAggregatesInput!]
	NOT: [PostScalarWhereWithAggregatesInput!]
	OR: [PostScalarWhereWithAggregatesInput!]
	authorId: IntWithAggregatesFilter
	content: StringNullableWithAggregatesFilter
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	published: BoolWithAggregatesFilter
	title: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type PostSumAggregate {
	authorId: Int
	id: Int
}

input PostSumOrderByAggregateInput {
	authorId: SortOrder
	id: SortOrder
}

input PostUpdateInput {
	author: UserUpdateOneRequiredWithoutPostInput
	content: NullableStringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	published: BoolFieldUpdateOperationsInput
	title: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
	content: NullableStringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	published: BoolFieldUpdateOperationsInput
	title: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyWithWhereWithoutAuthorInput {
	data: PostUpdateManyMutationInput!
	where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAuthorInput {
	connect: [PostWhereUniqueInput!]
	connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
	create: [PostCreateWithoutAuthorInput!]
	createMany: PostCreateManyAuthorInputEnvelope
	delete: [PostWhereUniqueInput!]
	deleteMany: [PostScalarWhereInput!]
	disconnect: [PostWhereUniqueInput!]
	set: [PostWhereUniqueInput!]
	update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
	updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
	upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
	data: PostUpdateWithoutAuthorInput!
	where: PostWhereUniqueInput!
}

input PostUpdateWithoutAuthorInput {
	content: NullableStringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	published: BoolFieldUpdateOperationsInput
	title: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
	create: PostCreateWithoutAuthorInput!
	update: PostUpdateWithoutAuthorInput!
	where: PostWhereUniqueInput!
}

input PostWhereInput {
	AND: [PostWhereInput!]
	NOT: [PostWhereInput!]
	OR: [PostWhereInput!]
	author: UserRelationFilter
	authorId: IntFilter
	content: StringNullableFilter
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	published: BoolFilter
	title: StringFilter
	updatedAt: DateTimeFilter
}

input PostWhereUniqueInput {
	id: Int
}

type Profile {
	bio: String
	createdAt: DateTime!
	deletedAt: DateTime
	firstName: String
	gender: Int
	genderLabel: String!
	id: Int!
	lastName: String
	linkedInUrl: String
	profilePicUrl: String
	updatedAt: DateTime!
	user: User!
	userId: Int!
}

type ProfileAvgAggregate {
	gender: Float
	id: Float
	userId: Float
}

input ProfileAvgOrderByAggregateInput {
	gender: SortOrder
	id: SortOrder
	userId: SortOrder
}

type ProfileCountAggregate {
	_all: Int!
	bio: Int!
	createdAt: Int!
	deletedAt: Int!
	firstName: Int!
	gender: Int!
	id: Int!
	lastName: Int!
	linkedInUrl: Int!
	profilePicUrl: Int!
	updatedAt: Int!
	userId: Int!
}

input ProfileCountOrderByAggregateInput {
	bio: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	firstName: SortOrder
	gender: SortOrder
	id: SortOrder
	lastName: SortOrder
	linkedInUrl: SortOrder
	profilePicUrl: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ProfileCreateInput {
	bio: String
	createdAt: DateTime
	deletedAt: DateTime
	firstName: String
	gender: Int
	lastName: String
	linkedInUrl: String
	profilePicUrl: String
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutProfileInput!
}

input ProfileCreateManyInput {
	bio: String
	createdAt: DateTime
	deletedAt: DateTime
	firstName: String
	gender: Int
	id: Int
	lastName: String
	linkedInUrl: String
	profilePicUrl: String
	updatedAt: DateTime
	userId: Int!
}

input ProfileCreateNestedOneWithoutUserInput {
	connect: ProfileWhereUniqueInput
	connectOrCreate: ProfileCreateOrConnectWithoutUserInput
	create: ProfileCreateWithoutUserInput
}

input ProfileCreateOrConnectWithoutUserInput {
	create: ProfileCreateWithoutUserInput!
	where: ProfileWhereUniqueInput!
}

input ProfileCreateWithoutUserInput {
	bio: String
	createdAt: DateTime
	deletedAt: DateTime
	firstName: String
	gender: Int
	lastName: String
	linkedInUrl: String
	profilePicUrl: String
	updatedAt: DateTime
}

type ProfileGroupBy {
	_avg: ProfileAvgAggregate
	_count: ProfileCountAggregate
	_max: ProfileMaxAggregate
	_min: ProfileMinAggregate
	_sum: ProfileSumAggregate
	bio: String
	createdAt: DateTime!
	deletedAt: DateTime
	firstName: String
	gender: Int
	id: Int!
	lastName: String
	linkedInUrl: String
	profilePicUrl: String
	updatedAt: DateTime!
	userId: Int!
}

type ProfileMaxAggregate {
	bio: String
	createdAt: DateTime
	deletedAt: DateTime
	firstName: String
	gender: Int
	id: Int
	lastName: String
	linkedInUrl: String
	profilePicUrl: String
	updatedAt: DateTime
	userId: Int
}

input ProfileMaxOrderByAggregateInput {
	bio: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	firstName: SortOrder
	gender: SortOrder
	id: SortOrder
	lastName: SortOrder
	linkedInUrl: SortOrder
	profilePicUrl: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

type ProfileMinAggregate {
	bio: String
	createdAt: DateTime
	deletedAt: DateTime
	firstName: String
	gender: Int
	id: Int
	lastName: String
	linkedInUrl: String
	profilePicUrl: String
	updatedAt: DateTime
	userId: Int
}

input ProfileMinOrderByAggregateInput {
	bio: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	firstName: SortOrder
	gender: SortOrder
	id: SortOrder
	lastName: SortOrder
	linkedInUrl: SortOrder
	profilePicUrl: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ProfileOrderByWithAggregationInput {
	_avg: ProfileAvgOrderByAggregateInput
	_count: ProfileCountOrderByAggregateInput
	_max: ProfileMaxOrderByAggregateInput
	_min: ProfileMinOrderByAggregateInput
	_sum: ProfileSumOrderByAggregateInput
	bio: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	firstName: SortOrder
	gender: SortOrder
	id: SortOrder
	lastName: SortOrder
	linkedInUrl: SortOrder
	profilePicUrl: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input ProfileOrderByWithRelationInput {
	bio: SortOrder
	createdAt: SortOrder
	deletedAt: SortOrder
	firstName: SortOrder
	gender: SortOrder
	id: SortOrder
	lastName: SortOrder
	linkedInUrl: SortOrder
	profilePicUrl: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
}

input ProfileRelationFilter {
	is: ProfileWhereInput
	isNot: ProfileWhereInput
}

enum ProfileScalarFieldEnum {
	bio
	createdAt
	deletedAt
	firstName
	gender
	id
	lastName
	linkedInUrl
	profilePicUrl
	updatedAt
	userId
}

input ProfileScalarWhereWithAggregatesInput {
	AND: [ProfileScalarWhereWithAggregatesInput!]
	NOT: [ProfileScalarWhereWithAggregatesInput!]
	OR: [ProfileScalarWhereWithAggregatesInput!]
	bio: StringNullableWithAggregatesFilter
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	firstName: StringNullableWithAggregatesFilter
	gender: IntNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	lastName: StringNullableWithAggregatesFilter
	linkedInUrl: StringNullableWithAggregatesFilter
	profilePicUrl: StringNullableWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
}

type ProfileSumAggregate {
	gender: Int
	id: Int
	userId: Int
}

input ProfileSumOrderByAggregateInput {
	gender: SortOrder
	id: SortOrder
	userId: SortOrder
}

input ProfileUpdateInput {
	bio: NullableStringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	firstName: NullableStringFieldUpdateOperationsInput
	gender: NullableIntFieldUpdateOperationsInput
	lastName: NullableStringFieldUpdateOperationsInput
	linkedInUrl: NullableStringFieldUpdateOperationsInput
	profilePicUrl: NullableStringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutProfileInput
}

input ProfileUpdateManyMutationInput {
	bio: NullableStringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	firstName: NullableStringFieldUpdateOperationsInput
	gender: NullableIntFieldUpdateOperationsInput
	lastName: NullableStringFieldUpdateOperationsInput
	linkedInUrl: NullableStringFieldUpdateOperationsInput
	profilePicUrl: NullableStringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProfileUpdateOneWithoutUserInput {
	connect: ProfileWhereUniqueInput
	connectOrCreate: ProfileCreateOrConnectWithoutUserInput
	create: ProfileCreateWithoutUserInput
	delete: Boolean
	disconnect: Boolean
	update: ProfileUpdateWithoutUserInput
	upsert: ProfileUpsertWithoutUserInput
}

input ProfileUpdateWithoutUserInput {
	bio: NullableStringFieldUpdateOperationsInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	firstName: NullableStringFieldUpdateOperationsInput
	gender: NullableIntFieldUpdateOperationsInput
	lastName: NullableStringFieldUpdateOperationsInput
	linkedInUrl: NullableStringFieldUpdateOperationsInput
	profilePicUrl: NullableStringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProfileUpsertWithoutUserInput {
	create: ProfileCreateWithoutUserInput!
	update: ProfileUpdateWithoutUserInput!
}

input ProfileWhereInput {
	AND: [ProfileWhereInput!]
	NOT: [ProfileWhereInput!]
	OR: [ProfileWhereInput!]
	bio: StringNullableFilter
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	firstName: StringNullableFilter
	gender: IntNullableFilter
	id: IntFilter
	lastName: StringNullableFilter
	linkedInUrl: StringNullableFilter
	profilePicUrl: StringNullableFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
}

input ProfileWhereUniqueInput {
	id: Int
	userId: Int
}

type Project {
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	updatedAt: DateTime!
}

type ProjectAvgAggregate {
	id: Float
}

input ProjectAvgOrderByAggregateInput {
	id: SortOrder
}

type ProjectCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	updatedAt: Int!
}

input ProjectCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

input ProjectCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	updatedAt: DateTime
}

input ProjectCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
}

type ProjectGroupBy {
	_avg: ProjectAvgAggregate
	_count: ProjectCountAggregate
	_max: ProjectMaxAggregate
	_min: ProjectMinAggregate
	_sum: ProjectSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	updatedAt: DateTime!
}

type ProjectMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
}

input ProjectMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

type ProjectMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
}

input ProjectMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

input ProjectOrderByWithAggregationInput {
	_avg: ProjectAvgOrderByAggregateInput
	_count: ProjectCountOrderByAggregateInput
	_max: ProjectMaxOrderByAggregateInput
	_min: ProjectMinOrderByAggregateInput
	_sum: ProjectSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

input ProjectOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

enum ProjectScalarFieldEnum {
	createdAt
	deletedAt
	id
	updatedAt
}

input ProjectScalarWhereWithAggregatesInput {
	AND: [ProjectScalarWhereWithAggregatesInput!]
	NOT: [ProjectScalarWhereWithAggregatesInput!]
	OR: [ProjectScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type ProjectSumAggregate {
	id: Int
}

input ProjectSumOrderByAggregateInput {
	id: SortOrder
}

input ProjectUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectWhereInput {
	AND: [ProjectWhereInput!]
	NOT: [ProjectWhereInput!]
	OR: [ProjectWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	updatedAt: DateTimeFilter
}

input ProjectWhereUniqueInput {
	id: Int
}

type Query {
	activities(
		cursor: ActivityWhereUniqueInput
		distinct: [ActivityScalarFieldEnum!]
		orderBy: [ActivityOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ActivityWhereInput
	): [Activity!]!
	activity(where: ActivityWhereUniqueInput!): Activity
	address(where: AddressWhereUniqueInput!): Address
	addresses(
		cursor: AddressWhereUniqueInput
		distinct: [AddressScalarFieldEnum!]
		orderBy: [AddressOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: AddressWhereInput
	): [Address!]!
	aggregateActivity(
		cursor: ActivityWhereUniqueInput
		orderBy: [ActivityOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ActivityWhereInput
	): AggregateActivity!
	aggregateAddress(
		cursor: AddressWhereUniqueInput
		orderBy: [AddressOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: AddressWhereInput
	): AggregateAddress!
	aggregateComment(
		cursor: CommentWhereUniqueInput
		orderBy: [CommentOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: CommentWhereInput
	): AggregateComment!
	aggregateCountry(
		cursor: CountryWhereUniqueInput
		orderBy: [CountryOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: CountryWhereInput
	): AggregateCountry!
	aggregateDomain(
		cursor: DomainWhereUniqueInput
		orderBy: [DomainOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: DomainWhereInput
	): AggregateDomain!
	aggregateEducation(
		cursor: EducationWhereUniqueInput
		orderBy: [EducationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: EducationWhereInput
	): AggregateEducation!
	aggregateEmploymentType(
		cursor: EmploymentTypeWhereUniqueInput
		orderBy: [EmploymentTypeOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: EmploymentTypeWhereInput
	): AggregateEmploymentType!
	aggregateExperience(
		cursor: ExperienceWhereUniqueInput
		orderBy: [ExperienceOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceWhereInput
	): AggregateExperience!
	aggregateExperienceRole(
		cursor: ExperienceRoleWhereUniqueInput
		orderBy: [ExperienceRoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceRoleWhereInput
	): AggregateExperienceRole!
	aggregateInvitation(
		cursor: InvitationWhereUniqueInput
		orderBy: [InvitationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: InvitationWhereInput
	): AggregateInvitation!
	aggregatePost(
		cursor: PostWhereUniqueInput
		orderBy: [PostOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: PostWhereInput
	): AggregatePost!
	aggregateProfile(
		cursor: ProfileWhereUniqueInput
		orderBy: [ProfileOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ProfileWhereInput
	): AggregateProfile!
	aggregateProject(
		cursor: ProjectWhereUniqueInput
		orderBy: [ProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ProjectWhereInput
	): AggregateProject!
	aggregateRole(
		cursor: RoleWhereUniqueInput
		orderBy: [RoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: RoleWhereInput
	): AggregateRole!
	aggregateScircle(
		cursor: ScircleWhereUniqueInput
		orderBy: [ScircleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ScircleWhereInput
	): AggregateScircle!
	aggregateSkill(
		cursor: SkillWhereUniqueInput
		orderBy: [SkillOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: SkillWhereInput
	): AggregateSkill!
	aggregateToken(
		cursor: TokenWhereUniqueInput
		orderBy: [TokenOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: TokenWhereInput
	): AggregateToken!
	aggregateUser(
		cursor: UserWhereUniqueInput
		orderBy: [UserOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserWhereInput
	): AggregateUser!
	aggregateUserProject(
		cursor: UserProjectWhereUniqueInput
		orderBy: [UserProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectWhereInput
	): AggregateUserProject!
	aggregateUserProjectRole(
		cursor: UserProjectRoleWhereUniqueInput
		orderBy: [UserProjectRoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectRoleWhereInput
	): AggregateUserProjectRole!
	aggregateUserRoleMapping(
		cursor: UserRoleMappingWhereUniqueInput
		orderBy: [UserRoleMappingOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserRoleMappingWhereInput
	): AggregateUserRoleMapping!
	comment(where: CommentWhereUniqueInput!): Comment
	comments(
		cursor: CommentWhereUniqueInput
		distinct: [CommentScalarFieldEnum!]
		orderBy: [CommentOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: CommentWhereInput
	): [Comment!]!
	countries(
		cursor: CountryWhereUniqueInput
		distinct: [CountryScalarFieldEnum!]
		orderBy: [CountryOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: CountryWhereInput
	): [Country!]!
	country(where: CountryWhereUniqueInput!): Country
	domain(where: DomainWhereUniqueInput!): Domain
	domains(
		cursor: DomainWhereUniqueInput
		distinct: [DomainScalarFieldEnum!]
		orderBy: [DomainOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: DomainWhereInput
	): [Domain!]!
	education(where: EducationWhereUniqueInput!): Education
	educations(
		cursor: EducationWhereUniqueInput
		distinct: [EducationScalarFieldEnum!]
		orderBy: [EducationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: EducationWhereInput
	): [Education!]!
	employmentType(where: EmploymentTypeWhereUniqueInput!): EmploymentType
	employmentTypes(
		cursor: EmploymentTypeWhereUniqueInput
		distinct: [EmploymentTypeScalarFieldEnum!]
		orderBy: [EmploymentTypeOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: EmploymentTypeWhereInput
	): [EmploymentType!]!
	experience(where: ExperienceWhereUniqueInput!): Experience
	experienceRole(where: ExperienceRoleWhereUniqueInput!): ExperienceRole
	experienceRoles(
		cursor: ExperienceRoleWhereUniqueInput
		distinct: [ExperienceRoleScalarFieldEnum!]
		orderBy: [ExperienceRoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceRoleWhereInput
	): [ExperienceRole!]!
	experiences(
		cursor: ExperienceWhereUniqueInput
		distinct: [ExperienceScalarFieldEnum!]
		orderBy: [ExperienceOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceWhereInput
	): [Experience!]!
	fetchMe: User!
	fetchOptions: String!
	findFirstActivity(
		cursor: ActivityWhereUniqueInput
		distinct: [ActivityScalarFieldEnum!]
		orderBy: [ActivityOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ActivityWhereInput
	): Activity
	findFirstAddress(
		cursor: AddressWhereUniqueInput
		distinct: [AddressScalarFieldEnum!]
		orderBy: [AddressOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: AddressWhereInput
	): Address
	findFirstComment(
		cursor: CommentWhereUniqueInput
		distinct: [CommentScalarFieldEnum!]
		orderBy: [CommentOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: CommentWhereInput
	): Comment
	findFirstCountry(
		cursor: CountryWhereUniqueInput
		distinct: [CountryScalarFieldEnum!]
		orderBy: [CountryOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: CountryWhereInput
	): Country
	findFirstDomain(
		cursor: DomainWhereUniqueInput
		distinct: [DomainScalarFieldEnum!]
		orderBy: [DomainOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: DomainWhereInput
	): Domain
	findFirstEducation(
		cursor: EducationWhereUniqueInput
		distinct: [EducationScalarFieldEnum!]
		orderBy: [EducationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: EducationWhereInput
	): Education
	findFirstEmploymentType(
		cursor: EmploymentTypeWhereUniqueInput
		distinct: [EmploymentTypeScalarFieldEnum!]
		orderBy: [EmploymentTypeOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: EmploymentTypeWhereInput
	): EmploymentType
	findFirstExperience(
		cursor: ExperienceWhereUniqueInput
		distinct: [ExperienceScalarFieldEnum!]
		orderBy: [ExperienceOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceWhereInput
	): Experience
	findFirstExperienceRole(
		cursor: ExperienceRoleWhereUniqueInput
		distinct: [ExperienceRoleScalarFieldEnum!]
		orderBy: [ExperienceRoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceRoleWhereInput
	): ExperienceRole
	findFirstInvitation(
		cursor: InvitationWhereUniqueInput
		distinct: [InvitationScalarFieldEnum!]
		orderBy: [InvitationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: InvitationWhereInput
	): Invitation
	findFirstPost(
		cursor: PostWhereUniqueInput
		distinct: [PostScalarFieldEnum!]
		orderBy: [PostOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: PostWhereInput
	): Post
	findFirstProfile(
		cursor: ProfileWhereUniqueInput
		distinct: [ProfileScalarFieldEnum!]
		orderBy: [ProfileOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ProfileWhereInput
	): Profile
	findFirstProject(
		cursor: ProjectWhereUniqueInput
		distinct: [ProjectScalarFieldEnum!]
		orderBy: [ProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ProjectWhereInput
	): Project
	findFirstRole(
		cursor: RoleWhereUniqueInput
		distinct: [RoleScalarFieldEnum!]
		orderBy: [RoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: RoleWhereInput
	): Role
	findFirstScircle(
		cursor: ScircleWhereUniqueInput
		distinct: [ScircleScalarFieldEnum!]
		orderBy: [ScircleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ScircleWhereInput
	): Scircle
	findFirstSkill(
		cursor: SkillWhereUniqueInput
		distinct: [SkillScalarFieldEnum!]
		orderBy: [SkillOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: SkillWhereInput
	): Skill
	findFirstToken(
		cursor: TokenWhereUniqueInput
		distinct: [TokenScalarFieldEnum!]
		orderBy: [TokenOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: TokenWhereInput
	): Token
	findFirstUser(
		cursor: UserWhereUniqueInput
		distinct: [UserScalarFieldEnum!]
		orderBy: [UserOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserWhereInput
	): User
	findFirstUserProject(
		cursor: UserProjectWhereUniqueInput
		distinct: [UserProjectScalarFieldEnum!]
		orderBy: [UserProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectWhereInput
	): UserProject
	findFirstUserProjectRole(
		cursor: UserProjectRoleWhereUniqueInput
		distinct: [UserProjectRoleScalarFieldEnum!]
		orderBy: [UserProjectRoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectRoleWhereInput
	): UserProjectRole
	findFirstUserRoleMapping(
		cursor: UserRoleMappingWhereUniqueInput
		distinct: [UserRoleMappingScalarFieldEnum!]
		orderBy: [UserRoleMappingOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserRoleMappingWhereInput
	): UserRoleMapping
	groupByActivity(
		by: [ActivityScalarFieldEnum!]!
		having: ActivityScalarWhereWithAggregatesInput
		orderBy: [ActivityOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: ActivityWhereInput
	): [ActivityGroupBy!]!
	groupByAddress(
		by: [AddressScalarFieldEnum!]!
		having: AddressScalarWhereWithAggregatesInput
		orderBy: [AddressOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: AddressWhereInput
	): [AddressGroupBy!]!
	groupByComment(
		by: [CommentScalarFieldEnum!]!
		having: CommentScalarWhereWithAggregatesInput
		orderBy: [CommentOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: CommentWhereInput
	): [CommentGroupBy!]!
	groupByCountry(
		by: [CountryScalarFieldEnum!]!
		having: CountryScalarWhereWithAggregatesInput
		orderBy: [CountryOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: CountryWhereInput
	): [CountryGroupBy!]!
	groupByDomain(
		by: [DomainScalarFieldEnum!]!
		having: DomainScalarWhereWithAggregatesInput
		orderBy: [DomainOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: DomainWhereInput
	): [DomainGroupBy!]!
	groupByEducation(
		by: [EducationScalarFieldEnum!]!
		having: EducationScalarWhereWithAggregatesInput
		orderBy: [EducationOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: EducationWhereInput
	): [EducationGroupBy!]!
	groupByEmploymentType(
		by: [EmploymentTypeScalarFieldEnum!]!
		having: EmploymentTypeScalarWhereWithAggregatesInput
		orderBy: [EmploymentTypeOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: EmploymentTypeWhereInput
	): [EmploymentTypeGroupBy!]!
	groupByExperience(
		by: [ExperienceScalarFieldEnum!]!
		having: ExperienceScalarWhereWithAggregatesInput
		orderBy: [ExperienceOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: ExperienceWhereInput
	): [ExperienceGroupBy!]!
	groupByExperienceRole(
		by: [ExperienceRoleScalarFieldEnum!]!
		having: ExperienceRoleScalarWhereWithAggregatesInput
		orderBy: [ExperienceRoleOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: ExperienceRoleWhereInput
	): [ExperienceRoleGroupBy!]!
	groupByInvitation(
		by: [InvitationScalarFieldEnum!]!
		having: InvitationScalarWhereWithAggregatesInput
		orderBy: [InvitationOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: InvitationWhereInput
	): [InvitationGroupBy!]!
	groupByPost(
		by: [PostScalarFieldEnum!]!
		having: PostScalarWhereWithAggregatesInput
		orderBy: [PostOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: PostWhereInput
	): [PostGroupBy!]!
	groupByProfile(
		by: [ProfileScalarFieldEnum!]!
		having: ProfileScalarWhereWithAggregatesInput
		orderBy: [ProfileOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: ProfileWhereInput
	): [ProfileGroupBy!]!
	groupByProject(
		by: [ProjectScalarFieldEnum!]!
		having: ProjectScalarWhereWithAggregatesInput
		orderBy: [ProjectOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: ProjectWhereInput
	): [ProjectGroupBy!]!
	groupByRole(
		by: [RoleScalarFieldEnum!]!
		having: RoleScalarWhereWithAggregatesInput
		orderBy: [RoleOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: RoleWhereInput
	): [RoleGroupBy!]!
	groupByScircle(
		by: [ScircleScalarFieldEnum!]!
		having: ScircleScalarWhereWithAggregatesInput
		orderBy: [ScircleOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: ScircleWhereInput
	): [ScircleGroupBy!]!
	groupBySkill(
		by: [SkillScalarFieldEnum!]!
		having: SkillScalarWhereWithAggregatesInput
		orderBy: [SkillOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: SkillWhereInput
	): [SkillGroupBy!]!
	groupByToken(
		by: [TokenScalarFieldEnum!]!
		having: TokenScalarWhereWithAggregatesInput
		orderBy: [TokenOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: TokenWhereInput
	): [TokenGroupBy!]!
	groupByUser(
		by: [UserScalarFieldEnum!]!
		having: UserScalarWhereWithAggregatesInput
		orderBy: [UserOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: UserWhereInput
	): [UserGroupBy!]!
	groupByUserProject(
		by: [UserProjectScalarFieldEnum!]!
		having: UserProjectScalarWhereWithAggregatesInput
		orderBy: [UserProjectOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: UserProjectWhereInput
	): [UserProjectGroupBy!]!
	groupByUserProjectRole(
		by: [UserProjectRoleScalarFieldEnum!]!
		having: UserProjectRoleScalarWhereWithAggregatesInput
		orderBy: [UserProjectRoleOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: UserProjectRoleWhereInput
	): [UserProjectRoleGroupBy!]!
	groupByUserRoleMapping(
		by: [UserRoleMappingScalarFieldEnum!]!
		having: UserRoleMappingScalarWhereWithAggregatesInput
		orderBy: [UserRoleMappingOrderByWithAggregationInput!]
		skip: Int
		take: Int
		where: UserRoleMappingWhereInput
	): [UserRoleMappingGroupBy!]!
	invitation(where: InvitationWhereUniqueInput!): Invitation
	invitations(
		cursor: InvitationWhereUniqueInput
		distinct: [InvitationScalarFieldEnum!]
		orderBy: [InvitationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: InvitationWhereInput
	): [Invitation!]!
	post(where: PostWhereUniqueInput!): Post
	posts(
		cursor: PostWhereUniqueInput
		distinct: [PostScalarFieldEnum!]
		orderBy: [PostOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: PostWhereInput
	): [Post!]!
	profile(where: ProfileWhereUniqueInput!): Profile
	profiles(
		cursor: ProfileWhereUniqueInput
		distinct: [ProfileScalarFieldEnum!]
		orderBy: [ProfileOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ProfileWhereInput
	): [Profile!]!
	project(where: ProjectWhereUniqueInput!): Project
	projects(
		cursor: ProjectWhereUniqueInput
		distinct: [ProjectScalarFieldEnum!]
		orderBy: [ProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ProjectWhereInput
	): [Project!]!
	role(where: RoleWhereUniqueInput!): Role
	roles(
		cursor: RoleWhereUniqueInput
		distinct: [RoleScalarFieldEnum!]
		orderBy: [RoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: RoleWhereInput
	): [Role!]!
	scircle(where: ScircleWhereUniqueInput!): Scircle
	scircles(
		cursor: ScircleWhereUniqueInput
		distinct: [ScircleScalarFieldEnum!]
		orderBy: [ScircleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ScircleWhereInput
	): [Scircle!]!
	skill(where: SkillWhereUniqueInput!): Skill
	skills(
		cursor: SkillWhereUniqueInput
		distinct: [SkillScalarFieldEnum!]
		orderBy: [SkillOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: SkillWhereInput
	): [Skill!]!
	token(where: TokenWhereUniqueInput!): Token
	tokens(
		cursor: TokenWhereUniqueInput
		distinct: [TokenScalarFieldEnum!]
		orderBy: [TokenOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: TokenWhereInput
	): [Token!]!
	user(where: UserWhereUniqueInput!): User
	userProject(where: UserProjectWhereUniqueInput!): UserProject
	userProjectRole(where: UserProjectRoleWhereUniqueInput!): UserProjectRole
	userProjectRoles(
		cursor: UserProjectRoleWhereUniqueInput
		distinct: [UserProjectRoleScalarFieldEnum!]
		orderBy: [UserProjectRoleOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectRoleWhereInput
	): [UserProjectRole!]!
	userProjects(
		cursor: UserProjectWhereUniqueInput
		distinct: [UserProjectScalarFieldEnum!]
		orderBy: [UserProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectWhereInput
	): [UserProject!]!
	userRoleMapping(where: UserRoleMappingWhereUniqueInput!): UserRoleMapping
	userRoleMappings(
		cursor: UserRoleMappingWhereUniqueInput
		distinct: [UserRoleMappingScalarFieldEnum!]
		orderBy: [UserRoleMappingOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserRoleMappingWhereInput
	): [UserRoleMapping!]!
	users(
		cursor: UserWhereUniqueInput
		distinct: [UserScalarFieldEnum!]
		orderBy: [UserOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserWhereInput
	): [User!]!
	verifyLinkedInUser(code: String!, state: String!): AccessTokenOutput!
}

enum QueryMode {
	default
	insensitive
}

input RegistrationInput {
	email: String!
	password: String!
}

type Role {
	UserRoleMapping(
		cursor: UserRoleMappingWhereUniqueInput
		distinct: [UserRoleMappingScalarFieldEnum!]
		orderBy: [UserRoleMappingOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserRoleMappingWhereInput
	): [UserRoleMapping!]!
	_count: RoleCount
	createdAt: DateTime!
	custom: Boolean!
	customPerms: JSON
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type RoleAvgAggregate {
	id: Float
}

input RoleAvgOrderByAggregateInput {
	id: SortOrder
}

type RoleCount {
	UserRoleMapping: Int!
}

type RoleCountAggregate {
	_all: Int!
	createdAt: Int!
	custom: Int!
	customPerms: Int!
	id: Int!
	name: Int!
	updatedAt: Int!
}

input RoleCountOrderByAggregateInput {
	createdAt: SortOrder
	custom: SortOrder
	customPerms: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input RoleCreateInput {
	UserRoleMapping: UserRoleMappingCreateNestedManyWithoutRoleInput
	createdAt: DateTime
	custom: Boolean
	customPerms: JSON
	name: String!
	updatedAt: DateTime
}

input RoleCreateManyInput {
	createdAt: DateTime
	custom: Boolean
	customPerms: JSON
	id: Int
	name: String!
	updatedAt: DateTime
}

input RoleCreateNestedOneWithoutUserRoleMappingInput {
	connect: RoleWhereUniqueInput
	connectOrCreate: RoleCreateOrConnectWithoutUserRoleMappingInput
	create: RoleCreateWithoutUserRoleMappingInput
}

input RoleCreateOrConnectWithoutUserRoleMappingInput {
	create: RoleCreateWithoutUserRoleMappingInput!
	where: RoleWhereUniqueInput!
}

input RoleCreateWithoutUserRoleMappingInput {
	createdAt: DateTime
	custom: Boolean
	customPerms: JSON
	name: String!
	updatedAt: DateTime
}

type RoleGroupBy {
	_avg: RoleAvgAggregate
	_count: RoleCountAggregate
	_max: RoleMaxAggregate
	_min: RoleMinAggregate
	_sum: RoleSumAggregate
	createdAt: DateTime!
	custom: Boolean!
	customPerms: JSON
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type RoleMaxAggregate {
	createdAt: DateTime
	custom: Boolean
	id: Int
	name: String
	updatedAt: DateTime
}

input RoleMaxOrderByAggregateInput {
	createdAt: SortOrder
	custom: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

type RoleMinAggregate {
	createdAt: DateTime
	custom: Boolean
	id: Int
	name: String
	updatedAt: DateTime
}

input RoleMinOrderByAggregateInput {
	createdAt: SortOrder
	custom: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input RoleOrderByWithAggregationInput {
	_avg: RoleAvgOrderByAggregateInput
	_count: RoleCountOrderByAggregateInput
	_max: RoleMaxOrderByAggregateInput
	_min: RoleMinOrderByAggregateInput
	_sum: RoleSumOrderByAggregateInput
	createdAt: SortOrder
	custom: SortOrder
	customPerms: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input RoleOrderByWithRelationInput {
	UserRoleMapping: UserRoleMappingOrderByRelationAggregateInput
	createdAt: SortOrder
	custom: SortOrder
	customPerms: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input RoleRelationFilter {
	is: RoleWhereInput
	isNot: RoleWhereInput
}

enum RoleScalarFieldEnum {
	createdAt
	custom
	customPerms
	id
	name
	updatedAt
}

input RoleScalarWhereWithAggregatesInput {
	AND: [RoleScalarWhereWithAggregatesInput!]
	NOT: [RoleScalarWhereWithAggregatesInput!]
	OR: [RoleScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	custom: BoolWithAggregatesFilter
	customPerms: JsonNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type RoleSumAggregate {
	id: Int
}

input RoleSumOrderByAggregateInput {
	id: SortOrder
}

input RoleUpdateInput {
	UserRoleMapping: UserRoleMappingUpdateManyWithoutRoleInput
	createdAt: DateTimeFieldUpdateOperationsInput
	custom: BoolFieldUpdateOperationsInput
	customPerms: JSON
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input RoleUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	custom: BoolFieldUpdateOperationsInput
	customPerms: JSON
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input RoleUpdateOneRequiredWithoutUserRoleMappingInput {
	connect: RoleWhereUniqueInput
	connectOrCreate: RoleCreateOrConnectWithoutUserRoleMappingInput
	create: RoleCreateWithoutUserRoleMappingInput
	update: RoleUpdateWithoutUserRoleMappingInput
	upsert: RoleUpsertWithoutUserRoleMappingInput
}

input RoleUpdateWithoutUserRoleMappingInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	custom: BoolFieldUpdateOperationsInput
	customPerms: JSON
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input RoleUpsertWithoutUserRoleMappingInput {
	create: RoleCreateWithoutUserRoleMappingInput!
	update: RoleUpdateWithoutUserRoleMappingInput!
}

input RoleWhereInput {
	AND: [RoleWhereInput!]
	NOT: [RoleWhereInput!]
	OR: [RoleWhereInput!]
	UserRoleMapping: UserRoleMappingListRelationFilter
	createdAt: DateTimeFilter
	custom: BoolFilter
	customPerms: JsonNullableFilter
	id: IntFilter
	name: StringFilter
	updatedAt: DateTimeFilter
}

input RoleWhereUniqueInput {
	id: Int
}

type Scircle {
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	updatedAt: DateTime!
}

type ScircleAvgAggregate {
	id: Float
}

input ScircleAvgOrderByAggregateInput {
	id: SortOrder
}

type ScircleCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	updatedAt: Int!
}

input ScircleCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

input ScircleCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	updatedAt: DateTime
}

input ScircleCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
}

type ScircleGroupBy {
	_avg: ScircleAvgAggregate
	_count: ScircleCountAggregate
	_max: ScircleMaxAggregate
	_min: ScircleMinAggregate
	_sum: ScircleSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	updatedAt: DateTime!
}

type ScircleMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
}

input ScircleMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

type ScircleMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	updatedAt: DateTime
}

input ScircleMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

input ScircleOrderByWithAggregationInput {
	_avg: ScircleAvgOrderByAggregateInput
	_count: ScircleCountOrderByAggregateInput
	_max: ScircleMaxOrderByAggregateInput
	_min: ScircleMinOrderByAggregateInput
	_sum: ScircleSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

input ScircleOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	updatedAt: SortOrder
}

enum ScircleScalarFieldEnum {
	createdAt
	deletedAt
	id
	updatedAt
}

input ScircleScalarWhereWithAggregatesInput {
	AND: [ScircleScalarWhereWithAggregatesInput!]
	NOT: [ScircleScalarWhereWithAggregatesInput!]
	OR: [ScircleScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type ScircleSumAggregate {
	id: Int
}

input ScircleSumOrderByAggregateInput {
	id: SortOrder
}

input ScircleUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScircleUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScircleWhereInput {
	AND: [ScircleWhereInput!]
	NOT: [ScircleWhereInput!]
	OR: [ScircleWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	updatedAt: DateTimeFilter
}

input ScircleWhereUniqueInput {
	id: Int
}

type SignInWithLinkendInOutput {
	url: String!
}

type Skill {
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type SkillAvgAggregate {
	id: Float
}

input SkillAvgOrderByAggregateInput {
	id: SortOrder
}

type SkillCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	name: Int!
	updatedAt: Int!
}

input SkillCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input SkillCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	name: String!
	updatedAt: DateTime
}

input SkillCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String!
	updatedAt: DateTime
}

type SkillGroupBy {
	_avg: SkillAvgAggregate
	_count: SkillCountAggregate
	_max: SkillMaxAggregate
	_min: SkillMinAggregate
	_sum: SkillSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type SkillMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input SkillMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

type SkillMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input SkillMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input SkillOrderByWithAggregationInput {
	_avg: SkillAvgOrderByAggregateInput
	_count: SkillCountOrderByAggregateInput
	_max: SkillMaxOrderByAggregateInput
	_min: SkillMinOrderByAggregateInput
	_sum: SkillSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input SkillOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

enum SkillScalarFieldEnum {
	createdAt
	deletedAt
	id
	name
	updatedAt
}

input SkillScalarWhereWithAggregatesInput {
	AND: [SkillScalarWhereWithAggregatesInput!]
	NOT: [SkillScalarWhereWithAggregatesInput!]
	OR: [SkillScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type SkillSumAggregate {
	id: Int
}

input SkillSumOrderByAggregateInput {
	id: SortOrder
}

input SkillUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input SkillUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input SkillWhereInput {
	AND: [SkillWhereInput!]
	NOT: [SkillWhereInput!]
	OR: [SkillWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	name: StringFilter
	updatedAt: DateTimeFilter
}

input SkillWhereUniqueInput {
	id: Int
}

enum SortOrder {
	asc
	desc
}

input StringFieldUpdateOperationsInput {
	set: String
}

input StringFilter {
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	mode: QueryMode
	not: NestedStringFilter
	notIn: [String!]
	startsWith: String
}

input StringNullableFilter {
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	mode: QueryMode
	not: NestedStringNullableFilter
	notIn: [String!]
	startsWith: String
}

input StringNullableWithAggregatesFilter {
	_count: NestedIntNullableFilter
	_max: NestedStringNullableFilter
	_min: NestedStringNullableFilter
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	mode: QueryMode
	not: NestedStringNullableWithAggregatesFilter
	notIn: [String!]
	startsWith: String
}

input StringWithAggregatesFilter {
	_count: NestedIntFilter
	_max: NestedStringFilter
	_min: NestedStringFilter
	contains: String
	endsWith: String
	equals: String
	gt: String
	gte: String
	in: [String!]
	lt: String
	lte: String
	mode: QueryMode
	not: NestedStringWithAggregatesFilter
	notIn: [String!]
	startsWith: String
}

type Token {
	createdAt: DateTime!
	expiresAt: DateTime!
	id: Int!
	token: String!
	updatedAt: DateTime!
	user: User!
	userId: Int!
}

type TokenAvgAggregate {
	id: Float
	userId: Float
}

input TokenAvgOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

type TokenCountAggregate {
	_all: Int!
	createdAt: Int!
	expiresAt: Int!
	id: Int!
	token: Int!
	updatedAt: Int!
	userId: Int!
}

input TokenCountOrderByAggregateInput {
	createdAt: SortOrder
	expiresAt: SortOrder
	id: SortOrder
	token: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input TokenCreateInput {
	createdAt: DateTime
	expiresAt: DateTime!
	token: String!
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutTokensInput!
}

input TokenCreateManyInput {
	createdAt: DateTime
	expiresAt: DateTime!
	id: Int
	token: String!
	updatedAt: DateTime
	userId: Int!
}

input TokenCreateManyUserInput {
	createdAt: DateTime
	expiresAt: DateTime!
	id: Int
	token: String!
	updatedAt: DateTime
}

input TokenCreateManyUserInputEnvelope {
	data: [TokenCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input TokenCreateNestedManyWithoutUserInput {
	connect: [TokenWhereUniqueInput!]
	connectOrCreate: [TokenCreateOrConnectWithoutUserInput!]
	create: [TokenCreateWithoutUserInput!]
	createMany: TokenCreateManyUserInputEnvelope
}

input TokenCreateOrConnectWithoutUserInput {
	create: TokenCreateWithoutUserInput!
	where: TokenWhereUniqueInput!
}

input TokenCreateWithoutUserInput {
	createdAt: DateTime
	expiresAt: DateTime!
	token: String!
	updatedAt: DateTime
}

type TokenGroupBy {
	_avg: TokenAvgAggregate
	_count: TokenCountAggregate
	_max: TokenMaxAggregate
	_min: TokenMinAggregate
	_sum: TokenSumAggregate
	createdAt: DateTime!
	expiresAt: DateTime!
	id: Int!
	token: String!
	updatedAt: DateTime!
	userId: Int!
}

input TokenListRelationFilter {
	every: TokenWhereInput
	none: TokenWhereInput
	some: TokenWhereInput
}

type TokenMaxAggregate {
	createdAt: DateTime
	expiresAt: DateTime
	id: Int
	token: String
	updatedAt: DateTime
	userId: Int
}

input TokenMaxOrderByAggregateInput {
	createdAt: SortOrder
	expiresAt: SortOrder
	id: SortOrder
	token: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

type TokenMinAggregate {
	createdAt: DateTime
	expiresAt: DateTime
	id: Int
	token: String
	updatedAt: DateTime
	userId: Int
}

input TokenMinOrderByAggregateInput {
	createdAt: SortOrder
	expiresAt: SortOrder
	id: SortOrder
	token: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input TokenOrderByRelationAggregateInput {
	_count: SortOrder
}

input TokenOrderByWithAggregationInput {
	_avg: TokenAvgOrderByAggregateInput
	_count: TokenCountOrderByAggregateInput
	_max: TokenMaxOrderByAggregateInput
	_min: TokenMinOrderByAggregateInput
	_sum: TokenSumOrderByAggregateInput
	createdAt: SortOrder
	expiresAt: SortOrder
	id: SortOrder
	token: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input TokenOrderByWithRelationInput {
	createdAt: SortOrder
	expiresAt: SortOrder
	id: SortOrder
	token: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
}

enum TokenScalarFieldEnum {
	createdAt
	expiresAt
	id
	token
	updatedAt
	userId
}

input TokenScalarWhereInput {
	AND: [TokenScalarWhereInput!]
	NOT: [TokenScalarWhereInput!]
	OR: [TokenScalarWhereInput!]
	createdAt: DateTimeFilter
	expiresAt: DateTimeFilter
	id: IntFilter
	token: StringFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
}

input TokenScalarWhereWithAggregatesInput {
	AND: [TokenScalarWhereWithAggregatesInput!]
	NOT: [TokenScalarWhereWithAggregatesInput!]
	OR: [TokenScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	expiresAt: DateTimeWithAggregatesFilter
	id: IntWithAggregatesFilter
	token: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
}

type TokenSumAggregate {
	id: Int
	userId: Int
}

input TokenSumOrderByAggregateInput {
	id: SortOrder
	userId: SortOrder
}

input TokenUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	expiresAt: DateTimeFieldUpdateOperationsInput
	token: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutTokensInput
}

input TokenUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	expiresAt: DateTimeFieldUpdateOperationsInput
	token: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input TokenUpdateManyWithWhereWithoutUserInput {
	data: TokenUpdateManyMutationInput!
	where: TokenScalarWhereInput!
}

input TokenUpdateManyWithoutUserInput {
	connect: [TokenWhereUniqueInput!]
	connectOrCreate: [TokenCreateOrConnectWithoutUserInput!]
	create: [TokenCreateWithoutUserInput!]
	createMany: TokenCreateManyUserInputEnvelope
	delete: [TokenWhereUniqueInput!]
	deleteMany: [TokenScalarWhereInput!]
	disconnect: [TokenWhereUniqueInput!]
	set: [TokenWhereUniqueInput!]
	update: [TokenUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [TokenUpdateManyWithWhereWithoutUserInput!]
	upsert: [TokenUpsertWithWhereUniqueWithoutUserInput!]
}

input TokenUpdateWithWhereUniqueWithoutUserInput {
	data: TokenUpdateWithoutUserInput!
	where: TokenWhereUniqueInput!
}

input TokenUpdateWithoutUserInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	expiresAt: DateTimeFieldUpdateOperationsInput
	token: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input TokenUpsertWithWhereUniqueWithoutUserInput {
	create: TokenCreateWithoutUserInput!
	update: TokenUpdateWithoutUserInput!
	where: TokenWhereUniqueInput!
}

input TokenWhereInput {
	AND: [TokenWhereInput!]
	NOT: [TokenWhereInput!]
	OR: [TokenWhereInput!]
	createdAt: DateTimeFilter
	expiresAt: DateTimeFilter
	id: IntFilter
	token: StringFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
}

input TokenWhereUniqueInput {
	id: Int
}

input UpdateUserProfileInput {
	addresses: [AddressCreateManyInput!]
	bio: String
	education: [EducationCreateManyInput!]
	experience: [ExperienceCreateManyInput!]
	firstName: String
	lastName: String
	projects: [ProjectCreateManyInput!]
}

type User {
	Post(
		cursor: PostWhereUniqueInput
		distinct: [PostScalarFieldEnum!]
		orderBy: [PostOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: PostWhereInput
	): [Post!]!
	_count: UserCount
	activity(
		cursor: ActivityWhereUniqueInput
		distinct: [ActivityScalarFieldEnum!]
		orderBy: [ActivityOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ActivityWhereInput
	): [Activity!]!
	addresses(
		cursor: AddressWhereUniqueInput
		distinct: [AddressScalarFieldEnum!]
		orderBy: [AddressOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: AddressWhereInput
	): [Address!]!
	comments(
		cursor: CommentWhereUniqueInput
		distinct: [CommentScalarFieldEnum!]
		orderBy: [CommentOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: CommentWhereInput
	): [Comment!]!
	createdAt: DateTime!
	deletedAt: DateTime
	education(
		cursor: EducationWhereUniqueInput
		distinct: [EducationScalarFieldEnum!]
		orderBy: [EducationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: EducationWhereInput
	): [Education!]!
	email: String!
	experience(
		cursor: ExperienceWhereUniqueInput
		distinct: [ExperienceScalarFieldEnum!]
		orderBy: [ExperienceOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: ExperienceWhereInput
	): [Experience!]!
	externalSource: Int!
	id: Int!
	invitationsReceived(
		cursor: InvitationWhereUniqueInput
		distinct: [InvitationScalarFieldEnum!]
		orderBy: [InvitationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: InvitationWhereInput
	): [Invitation!]!
	invitationsSent(
		cursor: InvitationWhereUniqueInput
		distinct: [InvitationScalarFieldEnum!]
		orderBy: [InvitationOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: InvitationWhereInput
	): [Invitation!]!
	password: String
	profile: Profile
	resetToken: String
	roleMapping(
		cursor: UserRoleMappingWhereUniqueInput
		distinct: [UserRoleMappingScalarFieldEnum!]
		orderBy: [UserRoleMappingOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserRoleMappingWhereInput
	): [UserRoleMapping!]!
	tokens(
		cursor: TokenWhereUniqueInput
		distinct: [TokenScalarFieldEnum!]
		orderBy: [TokenOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: TokenWhereInput
	): [Token!]!
	updatedAt: DateTime!
	userProject(
		cursor: UserProjectWhereUniqueInput
		distinct: [UserProjectScalarFieldEnum!]
		orderBy: [UserProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectWhereInput
	): [UserProject!]!
}

type UserAvgAggregate {
	externalSource: Float
	id: Float
}

input UserAvgOrderByAggregateInput {
	externalSource: SortOrder
	id: SortOrder
}

type UserCount {
	Post: Int!
	activity: Int!
	addresses: Int!
	comments: Int!
	education: Int!
	experience: Int!
	invitationsReceived: Int!
	invitationsSent: Int!
	roleMapping: Int!
	tokens: Int!
	userProject: Int!
}

type UserCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	email: Int!
	externalSource: Int!
	id: Int!
	password: Int!
	resetToken: Int!
	updatedAt: Int!
}

input UserCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	email: SortOrder
	externalSource: SortOrder
	id: SortOrder
	password: SortOrder
	resetToken: SortOrder
	updatedAt: SortOrder
}

input UserCreateInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	email: String!
	externalSource: Int!
	id: Int
	password: String
	resetToken: String
	updatedAt: DateTime
}

input UserCreateNestedOneWithoutActivityInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutActivityInput
	create: UserCreateWithoutActivityInput
}

input UserCreateNestedOneWithoutAddressesInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutAddressesInput
	create: UserCreateWithoutAddressesInput
}

input UserCreateNestedOneWithoutCommentsInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutCommentsInput
	create: UserCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutEducationInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutEducationInput
	create: UserCreateWithoutEducationInput
}

input UserCreateNestedOneWithoutExperienceInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutExperienceInput
	create: UserCreateWithoutExperienceInput
}

input UserCreateNestedOneWithoutInvitationsReceivedInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutInvitationsReceivedInput
	create: UserCreateWithoutInvitationsReceivedInput
}

input UserCreateNestedOneWithoutInvitationsSentInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutInvitationsSentInput
	create: UserCreateWithoutInvitationsSentInput
}

input UserCreateNestedOneWithoutPostInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutPostInput
	create: UserCreateWithoutPostInput
}

input UserCreateNestedOneWithoutProfileInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutProfileInput
	create: UserCreateWithoutProfileInput
}

input UserCreateNestedOneWithoutRoleMappingInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutRoleMappingInput
	create: UserCreateWithoutRoleMappingInput
}

input UserCreateNestedOneWithoutTokensInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutTokensInput
	create: UserCreateWithoutTokensInput
}

input UserCreateNestedOneWithoutUserProjectInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutUserProjectInput
	create: UserCreateWithoutUserProjectInput
}

input UserCreateOrConnectWithoutActivityInput {
	create: UserCreateWithoutActivityInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutAddressesInput {
	create: UserCreateWithoutAddressesInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCommentsInput {
	create: UserCreateWithoutCommentsInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutEducationInput {
	create: UserCreateWithoutEducationInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutExperienceInput {
	create: UserCreateWithoutExperienceInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutInvitationsReceivedInput {
	create: UserCreateWithoutInvitationsReceivedInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutInvitationsSentInput {
	create: UserCreateWithoutInvitationsSentInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutPostInput {
	create: UserCreateWithoutPostInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProfileInput {
	create: UserCreateWithoutProfileInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRoleMappingInput {
	create: UserCreateWithoutRoleMappingInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTokensInput {
	create: UserCreateWithoutTokensInput!
	where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutUserProjectInput {
	create: UserCreateWithoutUserProjectInput!
	where: UserWhereUniqueInput!
}

input UserCreateWithoutActivityInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutAddressesInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutCommentsInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutEducationInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutExperienceInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutInvitationsReceivedInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutInvitationsSentInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutPostInput {
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutProfileInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutRoleMappingInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutTokensInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutUserInput
}

input UserCreateWithoutUserProjectInput {
	Post: PostCreateNestedManyWithoutAuthorInput
	activity: ActivityCreateNestedManyWithoutUserInput
	addresses: AddressCreateNestedManyWithoutUserInput
	comments: CommentCreateNestedManyWithoutUserInput
	createdAt: DateTime
	deletedAt: DateTime
	education: EducationCreateNestedManyWithoutUserInput
	email: String!
	experience: ExperienceCreateNestedManyWithoutUserInput
	externalSource: Int!
	invitationsReceived: InvitationCreateNestedManyWithoutRecepientUserInput
	invitationsSent: InvitationCreateNestedManyWithoutCreatedByInput
	password: String
	profile: ProfileCreateNestedOneWithoutUserInput
	resetToken: String
	roleMapping: UserRoleMappingCreateNestedManyWithoutUserInput
	tokens: TokenCreateNestedManyWithoutUserInput
	updatedAt: DateTime
}

type UserGroupBy {
	_avg: UserAvgAggregate
	_count: UserCountAggregate
	_max: UserMaxAggregate
	_min: UserMinAggregate
	_sum: UserSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	email: String!
	externalSource: Int!
	id: Int!
	password: String
	resetToken: String
	updatedAt: DateTime!
}

type UserMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	email: String
	externalSource: Int
	id: Int
	password: String
	resetToken: String
	updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	email: SortOrder
	externalSource: SortOrder
	id: SortOrder
	password: SortOrder
	resetToken: SortOrder
	updatedAt: SortOrder
}

type UserMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	email: String
	externalSource: Int
	id: Int
	password: String
	resetToken: String
	updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	email: SortOrder
	externalSource: SortOrder
	id: SortOrder
	password: SortOrder
	resetToken: SortOrder
	updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
	_avg: UserAvgOrderByAggregateInput
	_count: UserCountOrderByAggregateInput
	_max: UserMaxOrderByAggregateInput
	_min: UserMinOrderByAggregateInput
	_sum: UserSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	email: SortOrder
	externalSource: SortOrder
	id: SortOrder
	password: SortOrder
	resetToken: SortOrder
	updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
	Post: PostOrderByRelationAggregateInput
	activity: ActivityOrderByRelationAggregateInput
	addresses: AddressOrderByRelationAggregateInput
	comments: CommentOrderByRelationAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	education: EducationOrderByRelationAggregateInput
	email: SortOrder
	experience: ExperienceOrderByRelationAggregateInput
	externalSource: SortOrder
	id: SortOrder
	invitationsReceived: InvitationOrderByRelationAggregateInput
	invitationsSent: InvitationOrderByRelationAggregateInput
	password: SortOrder
	profile: ProfileOrderByWithRelationInput
	resetToken: SortOrder
	roleMapping: UserRoleMappingOrderByRelationAggregateInput
	tokens: TokenOrderByRelationAggregateInput
	updatedAt: SortOrder
	userProject: UserProjectOrderByRelationAggregateInput
}

type UserProject {
	createdAt: DateTime!
	deletedAt: DateTime
	description: String!
	from: DateTime!
	id: Int!
	name: String!
	projectURL: String!
	role: UserProjectRole!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime!
	user: User!
	userId: Int!
	userProjectRoleId: Int!
}

type UserProjectAvgAggregate {
	id: Float
	teamSize: Float
	userId: Float
	userProjectRoleId: Float
}

input UserProjectAvgOrderByAggregateInput {
	id: SortOrder
	teamSize: SortOrder
	userId: SortOrder
	userProjectRoleId: SortOrder
}

type UserProjectCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	description: Int!
	from: Int!
	id: Int!
	name: Int!
	projectURL: Int!
	teamSize: Int!
	to: Int!
	updatedAt: Int!
	userId: Int!
	userProjectRoleId: Int!
}

input UserProjectCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	from: SortOrder
	id: SortOrder
	name: SortOrder
	projectURL: SortOrder
	teamSize: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	userProjectRoleId: SortOrder
}

input UserProjectCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	from: DateTime!
	name: String!
	projectURL: String!
	role: UserProjectRoleCreateNestedOneWithoutUserProjectInput!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutUserProjectInput!
}

input UserProjectCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	from: DateTime!
	id: Int
	name: String!
	projectURL: String!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime
	userId: Int!
	userProjectRoleId: Int!
}

input UserProjectCreateManyRoleInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	from: DateTime!
	id: Int
	name: String!
	projectURL: String!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime
	userId: Int!
}

input UserProjectCreateManyRoleInputEnvelope {
	data: [UserProjectCreateManyRoleInput!]!
	skipDuplicates: Boolean
}

input UserProjectCreateManyUserInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	from: DateTime!
	id: Int
	name: String!
	projectURL: String!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime
	userProjectRoleId: Int!
}

input UserProjectCreateManyUserInputEnvelope {
	data: [UserProjectCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input UserProjectCreateNestedManyWithoutRoleInput {
	connect: [UserProjectWhereUniqueInput!]
	connectOrCreate: [UserProjectCreateOrConnectWithoutRoleInput!]
	create: [UserProjectCreateWithoutRoleInput!]
	createMany: UserProjectCreateManyRoleInputEnvelope
}

input UserProjectCreateNestedManyWithoutUserInput {
	connect: [UserProjectWhereUniqueInput!]
	connectOrCreate: [UserProjectCreateOrConnectWithoutUserInput!]
	create: [UserProjectCreateWithoutUserInput!]
	createMany: UserProjectCreateManyUserInputEnvelope
}

input UserProjectCreateOrConnectWithoutRoleInput {
	create: UserProjectCreateWithoutRoleInput!
	where: UserProjectWhereUniqueInput!
}

input UserProjectCreateOrConnectWithoutUserInput {
	create: UserProjectCreateWithoutUserInput!
	where: UserProjectWhereUniqueInput!
}

input UserProjectCreateWithoutRoleInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	from: DateTime!
	name: String!
	projectURL: String!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutUserProjectInput!
}

input UserProjectCreateWithoutUserInput {
	createdAt: DateTime
	deletedAt: DateTime
	description: String!
	from: DateTime!
	name: String!
	projectURL: String!
	role: UserProjectRoleCreateNestedOneWithoutUserProjectInput!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime
}

type UserProjectGroupBy {
	_avg: UserProjectAvgAggregate
	_count: UserProjectCountAggregate
	_max: UserProjectMaxAggregate
	_min: UserProjectMinAggregate
	_sum: UserProjectSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	description: String!
	from: DateTime!
	id: Int!
	name: String!
	projectURL: String!
	teamSize: Int!
	to: DateTime
	updatedAt: DateTime!
	userId: Int!
	userProjectRoleId: Int!
}

input UserProjectListRelationFilter {
	every: UserProjectWhereInput
	none: UserProjectWhereInput
	some: UserProjectWhereInput
}

type UserProjectMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	from: DateTime
	id: Int
	name: String
	projectURL: String
	teamSize: Int
	to: DateTime
	updatedAt: DateTime
	userId: Int
	userProjectRoleId: Int
}

input UserProjectMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	from: SortOrder
	id: SortOrder
	name: SortOrder
	projectURL: SortOrder
	teamSize: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	userProjectRoleId: SortOrder
}

type UserProjectMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	description: String
	from: DateTime
	id: Int
	name: String
	projectURL: String
	teamSize: Int
	to: DateTime
	updatedAt: DateTime
	userId: Int
	userProjectRoleId: Int
}

input UserProjectMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	from: SortOrder
	id: SortOrder
	name: SortOrder
	projectURL: SortOrder
	teamSize: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	userProjectRoleId: SortOrder
}

input UserProjectOrderByRelationAggregateInput {
	_count: SortOrder
}

input UserProjectOrderByWithAggregationInput {
	_avg: UserProjectAvgOrderByAggregateInput
	_count: UserProjectCountOrderByAggregateInput
	_max: UserProjectMaxOrderByAggregateInput
	_min: UserProjectMinOrderByAggregateInput
	_sum: UserProjectSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	from: SortOrder
	id: SortOrder
	name: SortOrder
	projectURL: SortOrder
	teamSize: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
	userProjectRoleId: SortOrder
}

input UserProjectOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	description: SortOrder
	from: SortOrder
	id: SortOrder
	name: SortOrder
	projectURL: SortOrder
	role: UserProjectRoleOrderByWithRelationInput
	teamSize: SortOrder
	to: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
	userProjectRoleId: SortOrder
}

type UserProjectRole {
	_count: UserProjectRoleCount
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
	userProject(
		cursor: UserProjectWhereUniqueInput
		distinct: [UserProjectScalarFieldEnum!]
		orderBy: [UserProjectOrderByWithRelationInput!]
		skip: Int
		take: Int
		where: UserProjectWhereInput
	): [UserProject!]!
}

type UserProjectRoleAvgAggregate {
	id: Float
}

input UserProjectRoleAvgOrderByAggregateInput {
	id: SortOrder
}

type UserProjectRoleCount {
	userProject: Int!
}

type UserProjectRoleCountAggregate {
	_all: Int!
	createdAt: Int!
	deletedAt: Int!
	id: Int!
	name: Int!
	updatedAt: Int!
}

input UserProjectRoleCountOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input UserProjectRoleCreateInput {
	createdAt: DateTime
	deletedAt: DateTime
	name: String!
	updatedAt: DateTime
	userProject: UserProjectCreateNestedManyWithoutRoleInput
}

input UserProjectRoleCreateManyInput {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String!
	updatedAt: DateTime
}

input UserProjectRoleCreateNestedOneWithoutUserProjectInput {
	connect: UserProjectRoleWhereUniqueInput
	connectOrCreate: UserProjectRoleCreateOrConnectWithoutUserProjectInput
	create: UserProjectRoleCreateWithoutUserProjectInput
}

input UserProjectRoleCreateOrConnectWithoutUserProjectInput {
	create: UserProjectRoleCreateWithoutUserProjectInput!
	where: UserProjectRoleWhereUniqueInput!
}

input UserProjectRoleCreateWithoutUserProjectInput {
	createdAt: DateTime
	deletedAt: DateTime
	name: String!
	updatedAt: DateTime
}

type UserProjectRoleGroupBy {
	_avg: UserProjectRoleAvgAggregate
	_count: UserProjectRoleCountAggregate
	_max: UserProjectRoleMaxAggregate
	_min: UserProjectRoleMinAggregate
	_sum: UserProjectRoleSumAggregate
	createdAt: DateTime!
	deletedAt: DateTime
	id: Int!
	name: String!
	updatedAt: DateTime!
}

type UserProjectRoleMaxAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input UserProjectRoleMaxOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

type UserProjectRoleMinAggregate {
	createdAt: DateTime
	deletedAt: DateTime
	id: Int
	name: String
	updatedAt: DateTime
}

input UserProjectRoleMinOrderByAggregateInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input UserProjectRoleOrderByWithAggregationInput {
	_avg: UserProjectRoleAvgOrderByAggregateInput
	_count: UserProjectRoleCountOrderByAggregateInput
	_max: UserProjectRoleMaxOrderByAggregateInput
	_min: UserProjectRoleMinOrderByAggregateInput
	_sum: UserProjectRoleSumOrderByAggregateInput
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
}

input UserProjectRoleOrderByWithRelationInput {
	createdAt: SortOrder
	deletedAt: SortOrder
	id: SortOrder
	name: SortOrder
	updatedAt: SortOrder
	userProject: UserProjectOrderByRelationAggregateInput
}

input UserProjectRoleRelationFilter {
	is: UserProjectRoleWhereInput
	isNot: UserProjectRoleWhereInput
}

enum UserProjectRoleScalarFieldEnum {
	createdAt
	deletedAt
	id
	name
	updatedAt
}

input UserProjectRoleScalarWhereWithAggregatesInput {
	AND: [UserProjectRoleScalarWhereWithAggregatesInput!]
	NOT: [UserProjectRoleScalarWhereWithAggregatesInput!]
	OR: [UserProjectRoleScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type UserProjectRoleSumAggregate {
	id: Int
}

input UserProjectRoleSumOrderByAggregateInput {
	id: SortOrder
}

input UserProjectRoleUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutRoleInput
}

input UserProjectRoleUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserProjectRoleUpdateOneRequiredWithoutUserProjectInput {
	connect: UserProjectRoleWhereUniqueInput
	connectOrCreate: UserProjectRoleCreateOrConnectWithoutUserProjectInput
	create: UserProjectRoleCreateWithoutUserProjectInput
	update: UserProjectRoleUpdateWithoutUserProjectInput
	upsert: UserProjectRoleUpsertWithoutUserProjectInput
}

input UserProjectRoleUpdateWithoutUserProjectInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserProjectRoleUpsertWithoutUserProjectInput {
	create: UserProjectRoleCreateWithoutUserProjectInput!
	update: UserProjectRoleUpdateWithoutUserProjectInput!
}

input UserProjectRoleWhereInput {
	AND: [UserProjectRoleWhereInput!]
	NOT: [UserProjectRoleWhereInput!]
	OR: [UserProjectRoleWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	id: IntFilter
	name: StringFilter
	updatedAt: DateTimeFilter
	userProject: UserProjectListRelationFilter
}

input UserProjectRoleWhereUniqueInput {
	id: Int
}

enum UserProjectScalarFieldEnum {
	createdAt
	deletedAt
	description
	from
	id
	name
	projectURL
	teamSize
	to
	updatedAt
	userId
	userProjectRoleId
}

input UserProjectScalarWhereInput {
	AND: [UserProjectScalarWhereInput!]
	NOT: [UserProjectScalarWhereInput!]
	OR: [UserProjectScalarWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	description: StringFilter
	from: DateTimeFilter
	id: IntFilter
	name: StringFilter
	projectURL: StringFilter
	teamSize: IntFilter
	to: DateTimeNullableFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
	userProjectRoleId: IntFilter
}

input UserProjectScalarWhereWithAggregatesInput {
	AND: [UserProjectScalarWhereWithAggregatesInput!]
	NOT: [UserProjectScalarWhereWithAggregatesInput!]
	OR: [UserProjectScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	description: StringWithAggregatesFilter
	from: DateTimeWithAggregatesFilter
	id: IntWithAggregatesFilter
	name: StringWithAggregatesFilter
	projectURL: StringWithAggregatesFilter
	teamSize: IntWithAggregatesFilter
	to: DateTimeNullableWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
	userProjectRoleId: IntWithAggregatesFilter
}

type UserProjectSumAggregate {
	id: Int
	teamSize: Int
	userId: Int
	userProjectRoleId: Int
}

input UserProjectSumOrderByAggregateInput {
	id: SortOrder
	teamSize: SortOrder
	userId: SortOrder
	userProjectRoleId: SortOrder
}

input UserProjectUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: StringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	projectURL: StringFieldUpdateOperationsInput
	role: UserProjectRoleUpdateOneRequiredWithoutUserProjectInput
	teamSize: IntFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutUserProjectInput
}

input UserProjectUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: StringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	projectURL: StringFieldUpdateOperationsInput
	teamSize: IntFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserProjectUpdateManyWithWhereWithoutRoleInput {
	data: UserProjectUpdateManyMutationInput!
	where: UserProjectScalarWhereInput!
}

input UserProjectUpdateManyWithWhereWithoutUserInput {
	data: UserProjectUpdateManyMutationInput!
	where: UserProjectScalarWhereInput!
}

input UserProjectUpdateManyWithoutRoleInput {
	connect: [UserProjectWhereUniqueInput!]
	connectOrCreate: [UserProjectCreateOrConnectWithoutRoleInput!]
	create: [UserProjectCreateWithoutRoleInput!]
	createMany: UserProjectCreateManyRoleInputEnvelope
	delete: [UserProjectWhereUniqueInput!]
	deleteMany: [UserProjectScalarWhereInput!]
	disconnect: [UserProjectWhereUniqueInput!]
	set: [UserProjectWhereUniqueInput!]
	update: [UserProjectUpdateWithWhereUniqueWithoutRoleInput!]
	updateMany: [UserProjectUpdateManyWithWhereWithoutRoleInput!]
	upsert: [UserProjectUpsertWithWhereUniqueWithoutRoleInput!]
}

input UserProjectUpdateManyWithoutUserInput {
	connect: [UserProjectWhereUniqueInput!]
	connectOrCreate: [UserProjectCreateOrConnectWithoutUserInput!]
	create: [UserProjectCreateWithoutUserInput!]
	createMany: UserProjectCreateManyUserInputEnvelope
	delete: [UserProjectWhereUniqueInput!]
	deleteMany: [UserProjectScalarWhereInput!]
	disconnect: [UserProjectWhereUniqueInput!]
	set: [UserProjectWhereUniqueInput!]
	update: [UserProjectUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [UserProjectUpdateManyWithWhereWithoutUserInput!]
	upsert: [UserProjectUpsertWithWhereUniqueWithoutUserInput!]
}

input UserProjectUpdateWithWhereUniqueWithoutRoleInput {
	data: UserProjectUpdateWithoutRoleInput!
	where: UserProjectWhereUniqueInput!
}

input UserProjectUpdateWithWhereUniqueWithoutUserInput {
	data: UserProjectUpdateWithoutUserInput!
	where: UserProjectWhereUniqueInput!
}

input UserProjectUpdateWithoutRoleInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: StringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	projectURL: StringFieldUpdateOperationsInput
	teamSize: IntFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutUserProjectInput
}

input UserProjectUpdateWithoutUserInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	description: StringFieldUpdateOperationsInput
	from: DateTimeFieldUpdateOperationsInput
	name: StringFieldUpdateOperationsInput
	projectURL: StringFieldUpdateOperationsInput
	role: UserProjectRoleUpdateOneRequiredWithoutUserProjectInput
	teamSize: IntFieldUpdateOperationsInput
	to: NullableDateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserProjectUpsertWithWhereUniqueWithoutRoleInput {
	create: UserProjectCreateWithoutRoleInput!
	update: UserProjectUpdateWithoutRoleInput!
	where: UserProjectWhereUniqueInput!
}

input UserProjectUpsertWithWhereUniqueWithoutUserInput {
	create: UserProjectCreateWithoutUserInput!
	update: UserProjectUpdateWithoutUserInput!
	where: UserProjectWhereUniqueInput!
}

input UserProjectWhereInput {
	AND: [UserProjectWhereInput!]
	NOT: [UserProjectWhereInput!]
	OR: [UserProjectWhereInput!]
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	description: StringFilter
	from: DateTimeFilter
	id: IntFilter
	name: StringFilter
	projectURL: StringFilter
	role: UserProjectRoleRelationFilter
	teamSize: IntFilter
	to: DateTimeNullableFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
	userProjectRoleId: IntFilter
}

input UserProjectWhereUniqueInput {
	id: Int
}

input UserRelationFilter {
	is: UserWhereInput
	isNot: UserWhereInput
}

type UserRoleMapping {
	createdAt: DateTime!
	id: Int!
	role: Role!
	roleId: Int!
	updatedAt: DateTime!
	user: User!
	userId: Int!
}

type UserRoleMappingAvgAggregate {
	id: Float
	roleId: Float
	userId: Float
}

input UserRoleMappingAvgOrderByAggregateInput {
	id: SortOrder
	roleId: SortOrder
	userId: SortOrder
}

type UserRoleMappingCountAggregate {
	_all: Int!
	createdAt: Int!
	id: Int!
	roleId: Int!
	updatedAt: Int!
	userId: Int!
}

input UserRoleMappingCountOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	roleId: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input UserRoleMappingCreateInput {
	createdAt: DateTime
	role: RoleCreateNestedOneWithoutUserRoleMappingInput!
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutRoleMappingInput!
}

input UserRoleMappingCreateManyInput {
	createdAt: DateTime
	id: Int
	roleId: Int!
	updatedAt: DateTime
	userId: Int!
}

input UserRoleMappingCreateManyRoleInput {
	createdAt: DateTime
	id: Int
	updatedAt: DateTime
	userId: Int!
}

input UserRoleMappingCreateManyRoleInputEnvelope {
	data: [UserRoleMappingCreateManyRoleInput!]!
	skipDuplicates: Boolean
}

input UserRoleMappingCreateManyUserInput {
	createdAt: DateTime
	id: Int
	roleId: Int!
	updatedAt: DateTime
}

input UserRoleMappingCreateManyUserInputEnvelope {
	data: [UserRoleMappingCreateManyUserInput!]!
	skipDuplicates: Boolean
}

input UserRoleMappingCreateNestedManyWithoutRoleInput {
	connect: [UserRoleMappingWhereUniqueInput!]
	connectOrCreate: [UserRoleMappingCreateOrConnectWithoutRoleInput!]
	create: [UserRoleMappingCreateWithoutRoleInput!]
	createMany: UserRoleMappingCreateManyRoleInputEnvelope
}

input UserRoleMappingCreateNestedManyWithoutUserInput {
	connect: [UserRoleMappingWhereUniqueInput!]
	connectOrCreate: [UserRoleMappingCreateOrConnectWithoutUserInput!]
	create: [UserRoleMappingCreateWithoutUserInput!]
	createMany: UserRoleMappingCreateManyUserInputEnvelope
}

input UserRoleMappingCreateOrConnectWithoutRoleInput {
	create: UserRoleMappingCreateWithoutRoleInput!
	where: UserRoleMappingWhereUniqueInput!
}

input UserRoleMappingCreateOrConnectWithoutUserInput {
	create: UserRoleMappingCreateWithoutUserInput!
	where: UserRoleMappingWhereUniqueInput!
}

input UserRoleMappingCreateWithoutRoleInput {
	createdAt: DateTime
	updatedAt: DateTime
	user: UserCreateNestedOneWithoutRoleMappingInput!
}

input UserRoleMappingCreateWithoutUserInput {
	createdAt: DateTime
	role: RoleCreateNestedOneWithoutUserRoleMappingInput!
	updatedAt: DateTime
}

type UserRoleMappingGroupBy {
	_avg: UserRoleMappingAvgAggregate
	_count: UserRoleMappingCountAggregate
	_max: UserRoleMappingMaxAggregate
	_min: UserRoleMappingMinAggregate
	_sum: UserRoleMappingSumAggregate
	createdAt: DateTime!
	id: Int!
	roleId: Int!
	updatedAt: DateTime!
	userId: Int!
}

input UserRoleMappingListRelationFilter {
	every: UserRoleMappingWhereInput
	none: UserRoleMappingWhereInput
	some: UserRoleMappingWhereInput
}

type UserRoleMappingMaxAggregate {
	createdAt: DateTime
	id: Int
	roleId: Int
	updatedAt: DateTime
	userId: Int
}

input UserRoleMappingMaxOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	roleId: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

type UserRoleMappingMinAggregate {
	createdAt: DateTime
	id: Int
	roleId: Int
	updatedAt: DateTime
	userId: Int
}

input UserRoleMappingMinOrderByAggregateInput {
	createdAt: SortOrder
	id: SortOrder
	roleId: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input UserRoleMappingOrderByRelationAggregateInput {
	_count: SortOrder
}

input UserRoleMappingOrderByWithAggregationInput {
	_avg: UserRoleMappingAvgOrderByAggregateInput
	_count: UserRoleMappingCountOrderByAggregateInput
	_max: UserRoleMappingMaxOrderByAggregateInput
	_min: UserRoleMappingMinOrderByAggregateInput
	_sum: UserRoleMappingSumOrderByAggregateInput
	createdAt: SortOrder
	id: SortOrder
	roleId: SortOrder
	updatedAt: SortOrder
	userId: SortOrder
}

input UserRoleMappingOrderByWithRelationInput {
	createdAt: SortOrder
	id: SortOrder
	role: RoleOrderByWithRelationInput
	roleId: SortOrder
	updatedAt: SortOrder
	user: UserOrderByWithRelationInput
	userId: SortOrder
}

enum UserRoleMappingScalarFieldEnum {
	createdAt
	id
	roleId
	updatedAt
	userId
}

input UserRoleMappingScalarWhereInput {
	AND: [UserRoleMappingScalarWhereInput!]
	NOT: [UserRoleMappingScalarWhereInput!]
	OR: [UserRoleMappingScalarWhereInput!]
	createdAt: DateTimeFilter
	id: IntFilter
	roleId: IntFilter
	updatedAt: DateTimeFilter
	userId: IntFilter
}

input UserRoleMappingScalarWhereWithAggregatesInput {
	AND: [UserRoleMappingScalarWhereWithAggregatesInput!]
	NOT: [UserRoleMappingScalarWhereWithAggregatesInput!]
	OR: [UserRoleMappingScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	id: IntWithAggregatesFilter
	roleId: IntWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
	userId: IntWithAggregatesFilter
}

type UserRoleMappingSumAggregate {
	id: Int
	roleId: Int
	userId: Int
}

input UserRoleMappingSumOrderByAggregateInput {
	id: SortOrder
	roleId: SortOrder
	userId: SortOrder
}

input UserRoleMappingUpdateInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	role: RoleUpdateOneRequiredWithoutUserRoleMappingInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutRoleMappingInput
}

input UserRoleMappingUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserRoleMappingUpdateManyWithWhereWithoutRoleInput {
	data: UserRoleMappingUpdateManyMutationInput!
	where: UserRoleMappingScalarWhereInput!
}

input UserRoleMappingUpdateManyWithWhereWithoutUserInput {
	data: UserRoleMappingUpdateManyMutationInput!
	where: UserRoleMappingScalarWhereInput!
}

input UserRoleMappingUpdateManyWithoutRoleInput {
	connect: [UserRoleMappingWhereUniqueInput!]
	connectOrCreate: [UserRoleMappingCreateOrConnectWithoutRoleInput!]
	create: [UserRoleMappingCreateWithoutRoleInput!]
	createMany: UserRoleMappingCreateManyRoleInputEnvelope
	delete: [UserRoleMappingWhereUniqueInput!]
	deleteMany: [UserRoleMappingScalarWhereInput!]
	disconnect: [UserRoleMappingWhereUniqueInput!]
	set: [UserRoleMappingWhereUniqueInput!]
	update: [UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput!]
	updateMany: [UserRoleMappingUpdateManyWithWhereWithoutRoleInput!]
	upsert: [UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput!]
}

input UserRoleMappingUpdateManyWithoutUserInput {
	connect: [UserRoleMappingWhereUniqueInput!]
	connectOrCreate: [UserRoleMappingCreateOrConnectWithoutUserInput!]
	create: [UserRoleMappingCreateWithoutUserInput!]
	createMany: UserRoleMappingCreateManyUserInputEnvelope
	delete: [UserRoleMappingWhereUniqueInput!]
	deleteMany: [UserRoleMappingScalarWhereInput!]
	disconnect: [UserRoleMappingWhereUniqueInput!]
	set: [UserRoleMappingWhereUniqueInput!]
	update: [UserRoleMappingUpdateWithWhereUniqueWithoutUserInput!]
	updateMany: [UserRoleMappingUpdateManyWithWhereWithoutUserInput!]
	upsert: [UserRoleMappingUpsertWithWhereUniqueWithoutUserInput!]
}

input UserRoleMappingUpdateWithWhereUniqueWithoutRoleInput {
	data: UserRoleMappingUpdateWithoutRoleInput!
	where: UserRoleMappingWhereUniqueInput!
}

input UserRoleMappingUpdateWithWhereUniqueWithoutUserInput {
	data: UserRoleMappingUpdateWithoutUserInput!
	where: UserRoleMappingWhereUniqueInput!
}

input UserRoleMappingUpdateWithoutRoleInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	user: UserUpdateOneRequiredWithoutRoleMappingInput
}

input UserRoleMappingUpdateWithoutUserInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	role: RoleUpdateOneRequiredWithoutUserRoleMappingInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserRoleMappingUpsertWithWhereUniqueWithoutRoleInput {
	create: UserRoleMappingCreateWithoutRoleInput!
	update: UserRoleMappingUpdateWithoutRoleInput!
	where: UserRoleMappingWhereUniqueInput!
}

input UserRoleMappingUpsertWithWhereUniqueWithoutUserInput {
	create: UserRoleMappingCreateWithoutUserInput!
	update: UserRoleMappingUpdateWithoutUserInput!
	where: UserRoleMappingWhereUniqueInput!
}

input UserRoleMappingWhereInput {
	AND: [UserRoleMappingWhereInput!]
	NOT: [UserRoleMappingWhereInput!]
	OR: [UserRoleMappingWhereInput!]
	createdAt: DateTimeFilter
	id: IntFilter
	role: RoleRelationFilter
	roleId: IntFilter
	updatedAt: DateTimeFilter
	user: UserRelationFilter
	userId: IntFilter
}

input UserRoleMappingWhereUniqueInput {
	id: Int
}

enum UserScalarFieldEnum {
	createdAt
	deletedAt
	email
	externalSource
	id
	password
	resetToken
	updatedAt
}

input UserScalarWhereWithAggregatesInput {
	AND: [UserScalarWhereWithAggregatesInput!]
	NOT: [UserScalarWhereWithAggregatesInput!]
	OR: [UserScalarWhereWithAggregatesInput!]
	createdAt: DateTimeWithAggregatesFilter
	deletedAt: DateTimeNullableWithAggregatesFilter
	email: StringWithAggregatesFilter
	externalSource: IntWithAggregatesFilter
	id: IntWithAggregatesFilter
	password: StringNullableWithAggregatesFilter
	resetToken: StringNullableWithAggregatesFilter
	updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
	externalSource: Int
	id: Int
}

input UserSumOrderByAggregateInput {
	externalSource: SortOrder
	id: SortOrder
}

input UserUpdateInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	email: StringFieldUpdateOperationsInput
	externalSource: IntFieldUpdateOperationsInput
	password: NullableStringFieldUpdateOperationsInput
	resetToken: NullableStringFieldUpdateOperationsInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutActivityInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutActivityInput
	create: UserCreateWithoutActivityInput
	update: UserUpdateWithoutActivityInput
	upsert: UserUpsertWithoutActivityInput
}

input UserUpdateOneRequiredWithoutAddressesInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutAddressesInput
	create: UserCreateWithoutAddressesInput
	update: UserUpdateWithoutAddressesInput
	upsert: UserUpsertWithoutAddressesInput
}

input UserUpdateOneRequiredWithoutCommentsInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutCommentsInput
	create: UserCreateWithoutCommentsInput
	update: UserUpdateWithoutCommentsInput
	upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateOneRequiredWithoutEducationInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutEducationInput
	create: UserCreateWithoutEducationInput
	update: UserUpdateWithoutEducationInput
	upsert: UserUpsertWithoutEducationInput
}

input UserUpdateOneRequiredWithoutExperienceInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutExperienceInput
	create: UserCreateWithoutExperienceInput
	update: UserUpdateWithoutExperienceInput
	upsert: UserUpsertWithoutExperienceInput
}

input UserUpdateOneRequiredWithoutInvitationsReceivedInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutInvitationsReceivedInput
	create: UserCreateWithoutInvitationsReceivedInput
	update: UserUpdateWithoutInvitationsReceivedInput
	upsert: UserUpsertWithoutInvitationsReceivedInput
}

input UserUpdateOneRequiredWithoutInvitationsSentInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutInvitationsSentInput
	create: UserCreateWithoutInvitationsSentInput
	update: UserUpdateWithoutInvitationsSentInput
	upsert: UserUpsertWithoutInvitationsSentInput
}

input UserUpdateOneRequiredWithoutPostInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutPostInput
	create: UserCreateWithoutPostInput
	update: UserUpdateWithoutPostInput
	upsert: UserUpsertWithoutPostInput
}

input UserUpdateOneRequiredWithoutProfileInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutProfileInput
	create: UserCreateWithoutProfileInput
	update: UserUpdateWithoutProfileInput
	upsert: UserUpsertWithoutProfileInput
}

input UserUpdateOneRequiredWithoutRoleMappingInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutRoleMappingInput
	create: UserCreateWithoutRoleMappingInput
	update: UserUpdateWithoutRoleMappingInput
	upsert: UserUpsertWithoutRoleMappingInput
}

input UserUpdateOneRequiredWithoutTokensInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutTokensInput
	create: UserCreateWithoutTokensInput
	update: UserUpdateWithoutTokensInput
	upsert: UserUpsertWithoutTokensInput
}

input UserUpdateOneRequiredWithoutUserProjectInput {
	connect: UserWhereUniqueInput
	connectOrCreate: UserCreateOrConnectWithoutUserProjectInput
	create: UserCreateWithoutUserProjectInput
	update: UserUpdateWithoutUserProjectInput
	upsert: UserUpsertWithoutUserProjectInput
}

input UserUpdateWithoutActivityInput {
	Post: PostUpdateManyWithoutAuthorInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutAddressesInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutCommentsInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutEducationInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutExperienceInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutInvitationsReceivedInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutInvitationsSentInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutPostInput {
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutProfileInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutRoleMappingInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutTokensInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
	userProject: UserProjectUpdateManyWithoutUserInput
}

input UserUpdateWithoutUserProjectInput {
	Post: PostUpdateManyWithoutAuthorInput
	activity: ActivityUpdateManyWithoutUserInput
	addresses: AddressUpdateManyWithoutUserInput
	comments: CommentUpdateManyWithoutUserInput
	createdAt: DateTimeFieldUpdateOperationsInput
	deletedAt: NullableDateTimeFieldUpdateOperationsInput
	education: EducationUpdateManyWithoutUserInput
	email: StringFieldUpdateOperationsInput
	experience: ExperienceUpdateManyWithoutUserInput
	externalSource: IntFieldUpdateOperationsInput
	invitationsReceived: InvitationUpdateManyWithoutRecepientUserInput
	invitationsSent: InvitationUpdateManyWithoutCreatedByInput
	password: NullableStringFieldUpdateOperationsInput
	profile: ProfileUpdateOneWithoutUserInput
	resetToken: NullableStringFieldUpdateOperationsInput
	roleMapping: UserRoleMappingUpdateManyWithoutUserInput
	tokens: TokenUpdateManyWithoutUserInput
	updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutActivityInput {
	create: UserCreateWithoutActivityInput!
	update: UserUpdateWithoutActivityInput!
}

input UserUpsertWithoutAddressesInput {
	create: UserCreateWithoutAddressesInput!
	update: UserUpdateWithoutAddressesInput!
}

input UserUpsertWithoutCommentsInput {
	create: UserCreateWithoutCommentsInput!
	update: UserUpdateWithoutCommentsInput!
}

input UserUpsertWithoutEducationInput {
	create: UserCreateWithoutEducationInput!
	update: UserUpdateWithoutEducationInput!
}

input UserUpsertWithoutExperienceInput {
	create: UserCreateWithoutExperienceInput!
	update: UserUpdateWithoutExperienceInput!
}

input UserUpsertWithoutInvitationsReceivedInput {
	create: UserCreateWithoutInvitationsReceivedInput!
	update: UserUpdateWithoutInvitationsReceivedInput!
}

input UserUpsertWithoutInvitationsSentInput {
	create: UserCreateWithoutInvitationsSentInput!
	update: UserUpdateWithoutInvitationsSentInput!
}

input UserUpsertWithoutPostInput {
	create: UserCreateWithoutPostInput!
	update: UserUpdateWithoutPostInput!
}

input UserUpsertWithoutProfileInput {
	create: UserCreateWithoutProfileInput!
	update: UserUpdateWithoutProfileInput!
}

input UserUpsertWithoutRoleMappingInput {
	create: UserCreateWithoutRoleMappingInput!
	update: UserUpdateWithoutRoleMappingInput!
}

input UserUpsertWithoutTokensInput {
	create: UserCreateWithoutTokensInput!
	update: UserUpdateWithoutTokensInput!
}

input UserUpsertWithoutUserProjectInput {
	create: UserCreateWithoutUserProjectInput!
	update: UserUpdateWithoutUserProjectInput!
}

input UserWhereInput {
	AND: [UserWhereInput!]
	NOT: [UserWhereInput!]
	OR: [UserWhereInput!]
	Post: PostListRelationFilter
	activity: ActivityListRelationFilter
	addresses: AddressListRelationFilter
	comments: CommentListRelationFilter
	createdAt: DateTimeFilter
	deletedAt: DateTimeNullableFilter
	education: EducationListRelationFilter
	email: StringFilter
	experience: ExperienceListRelationFilter
	externalSource: IntFilter
	id: IntFilter
	invitationsReceived: InvitationListRelationFilter
	invitationsSent: InvitationListRelationFilter
	password: StringNullableFilter
	profile: ProfileRelationFilter
	resetToken: StringNullableFilter
	roleMapping: UserRoleMappingListRelationFilter
	tokens: TokenListRelationFilter
	updatedAt: DateTimeFilter
	userProject: UserProjectListRelationFilter
}

input UserWhereUniqueInput {
	email: String
	id: Int
}
